6abb648a16c4fa55c7a3edb30760f40a
"use strict";
// test/unit/common/guards/auth.guard.edge-cases.spec.ts
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const axios_1 = require("@nestjs/axios");
const testing_1 = require("@nestjs/testing");
const rxjs_1 = require("rxjs");
const axios_2 = require("axios");
const auth_guard_1 = require("../../../../src/common/guards/auth.guard");
const cache_service_1 = require("../../../../src/cache/cache.service");
describe('AuthGuard - Edge Cases', () => {
    let authGuard;
    let configService;
    let cacheService;
    let httpService;
    // ============================================================================
    // HELPERS SPÉCIALISÉS POUR LES CAS LIMITES
    // ============================================================================
    const createMockExecutionContext = (request) => {
        return {
            switchToHttp: () => ({
                getRequest: () => request,
                getResponse: jest.fn(),
                getNext: jest.fn(),
            }),
            switchToRpc: jest.fn(),
            switchToWs: jest.fn(),
            getType: () => 'http',
            getClass: jest.fn(),
            getHandler: jest.fn(),
            getArgs: jest.fn(),
            getArgByIndex: jest.fn(),
        };
    };
    const createExtremeUser = (type) => {
        switch (type) {
            case 'minimal':
                return {
                    id: 'a',
                    email: 'a@b.c',
                    roles: ['r'],
                };
            case 'maximal':
                return {
                    id: 'user-' + 'x'.repeat(1000),
                    email: 'very-long-email-address-' + 'x'.repeat(200) + '@very-long-domain-name-' + 'x'.repeat(100) + '.example.com',
                    roles: Array.from({ length: 100 }, (_, i) => `role-${i}-${'x'.repeat(50)}`),
                };
            case 'unicode':
                return {
                    id: '用户-123-αβγ-🚀',
                    email: 'тест@пример.рф',
                    roles: ['用户', 'διαχειριστής', '🔐-admin'],
                };
            case 'numeric':
                return {
                    id: '123456789',
                    email: '123@456.789',
                    roles: ['0', '1', '2'],
                };
            default:
                throw new Error('Unknown user type');
        }
    };
    const createMalformedTokens = () => [
        '', // Empty
        ' ', // Space only
        '\t', // Tab
        '\n', // Newline
        'token with spaces',
        'token\nwith\nnewlines',
        'token\twith\ttabs',
        'token.with.only.two.parts',
        'token.with.too.many.parts.here.and.here',
        'toke123',
        '......',
        'Bearer token', // Double Bearer
        'a'.repeat(10000), // Très long
        '\u0000token\u0000', // Null bytes
        'token🚀with🔐emojis',
        'token-with-unicode-αβγ-characters',
    ];
    const createBoundaryValues = () => ({
        largeNumbers: [
            Number.MAX_SAFE_INTEGER,
            Number.MIN_SAFE_INTEGER,
            Number.MAX_VALUE,
            Number.MIN_VALUE,
            Infinity,
            -Infinity,
        ],
        specialStrings: [
            '',
            ' ',
            '  ',
            '\n',
            '\r',
            '\t',
            '\r\n',
            '\0',
            String.fromCharCode(0),
            String.fromCharCode(65535),
            '\\',
            '/',
            '"',
            "'",
            '`',
            '$',
            '%',
            '&',
            '<script>',
            'SELECT * FROM users',
            '../../../etc/passwd',
            'C:\\Windows\\System32',
        ],
        edgeDates: [
            new Date(0), // Unix epoch
            new Date('1970-01-01T00:00:00.000Z'),
            new Date('2038-01-19T03:14:07.000Z'), // 32-bit timestamp limit
            new Date('9999-12-31T23:59:59.999Z'),
            new Date('Invalid Date'),
        ],
    });
    // ============================================================================
    // SETUP
    // ============================================================================
    beforeEach(async () => {
        const module = await testing_1.Test.createTestingModule({
            providers: [
                auth_guard_1.AuthGuard,
                {
                    provide: config_1.ConfigService,
                    useValue: {
                        get: jest.fn(),
                    },
                },
                {
                    provide: cache_service_1.CacheService,
                    useValue: {
                        get: jest.fn(),
                        set: jest.fn(),
                        del: jest.fn(),
                    },
                },
                {
                    provide: axios_1.HttpService,
                    useValue: {
                        post: jest.fn(),
                    },
                },
            ],
        }).compile();
        authGuard = module.get(auth_guard_1.AuthGuard);
        configService = module.get(config_1.ConfigService);
        cacheService = module.get(cache_service_1.CacheService);
        httpService = module.get(axios_1.HttpService);
        configService.get.mockImplementation((key) => {
            switch (key) {
                case 'AUTH_SERVICE_URL':
                    return 'http://localhost:3001';
                case 'AUTH_SERVICE_TIMEOUT':
                    return '5000';
                default:
                    return undefined;
            }
        });
        process.env.AUTH_SERVICE_URL = 'http://localhost:3001';
        process.env.AUTH_SERVICE_TIMEOUT = '5000';
    });
    afterEach(() => {
        jest.clearAllMocks();
        jest.restoreAllMocks();
    });
    // ============================================================================
    // TESTS - TOKENS EXTRÊMES
    // ============================================================================
    describe('Extreme Token Cases', () => {
        it('should handle empty and whitespace tokens', async () => {
            // Arrange
            const invalidTokens = ['', ' ', '\t', '\n', '\r\n', '   '];
            for (const token of invalidTokens) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                // Act & Assert
                await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
            }
        });
        it('should handle extremely long tokens', async () => {
            // Arrange
            const veryLongToken = 'a'.repeat(100000); // 100KB token
            const request = { headers: { authorization: `Bearer ${veryLongToken}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Request too large', '413')));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow();
        });
        it('should handle tokens with special characters', async () => {
            // Arrange
            const specialTokens = createMalformedTokens();
            for (const token of specialTokens) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(null);
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Invalid token', '400')));
                // Act & Assert
                await expect(authGuard.canActivate(context)).rejects.toThrow();
            }
        });
        it('should handle tokens with unicode characters', async () => {
            // Arrange
            const unicodeTokens = [
                'тест.токен.подпись',
                'テスト.トークン.署名',
                '测试.令牌.签名',
                'test.🚀.signature',
                'token.with.αβγ.characters',
            ];
            for (const token of unicodeTokens) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(null);
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Invalid token', '400')));
                // Act & Assert
                await expect(authGuard.canActivate(context)).rejects.toThrow();
            }
        });
        it('should handle tokens with null bytes', async () => {
            // Arrange
            const nullByteTokens = [
                'token\x00with\x00nulls',
                '\x00token',
                'token\x00',
                'before\x00null\x00after',
            ];
            for (const token of nullByteTokens) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                // Act & Assert
                await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
            }
        });
        it('should handle malformed JWT structure', async () => {
            // Arrange
            const malformedJWTs = [
                'header', // Only one part
                'header.payload', // Only two parts
                'header.payload.signature.extra', // Too many parts
                '.payload.signature', // Empty header
                'header..signature', // Empty payload
                'header.payload.', // Empty signature
                '..', // All empty
                'header.payload.signature.', // Trailing dot
                '.header.payload.signature', // Leading dot
            ];
            for (const jwt of malformedJWTs) {
                const request = { headers: { authorization: `Bearer ${jwt}` } };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(null);
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Malformed JWT', '400')));
                // Act & Assert
                await expect(authGuard.canActivate(context)).rejects.toThrow();
            }
        });
    });
    // ============================================================================
    // TESTS - HEADERS EXTRÊMES
    // ============================================================================
    describe('Extreme Header Cases', () => {
        it('should handle headers with different cases', async () => {
            // Arrange
            const headerVariations = [
                'authorization',
                'Authorization',
                'AUTHORIZATION',
                'AuThOrIzAtIoN',
            ];
            for (const headerName of headerVariations) {
                const headers = { [headerName]: 'Bearer valid-token' };
                const request = { headers };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(null);
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Invalid', '401')));
                // Act & Assert
                // Le behavior peut varier selon l'implémentation
                // La plupart des serveurs normalisent les headers
                await expect(authGuard.canActivate(context)).rejects.toThrow();
            }
        });
        it('should handle multiple authorization headers', async () => {
            // Arrange
            const request = {
                headers: {
                    authorization: ['Bearer token1', 'Bearer token2'],
                },
            };
            const context = createMockExecutionContext(request);
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
        });
        it('should handle extremely large headers', async () => {
            // Arrange
            const largeToken = 'token' + 'x'.repeat(50000);
            const request = {
                headers: {
                    authorization: 'Bearer token1', // Une seule valeur au lieu d'un array
                },
            };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new Error('Headers too large')));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow();
        });
        it('should handle headers with special characters', async () => {
            // Arrange
            const request = {
                headers: {
                    authorization: 'Bearer valid-token',
                    'x-special': 'value\r\nInjected: header',
                    'x-unicode': 'тест-значение-🚀',
                    'x-null': 'value\x00with\x00nulls',
                },
            };
            const context = createMockExecutionContext(request);
            const user = createExtremeUser('minimal');
            cacheService.get.mockResolvedValue(user);
            // Act
            const result = await authGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            // Le guard doit sanitizer les headers avant de les utiliser
        });
    });
    // ============================================================================
    // TESTS - RÉPONSES DU SERVICE D'AUTH EXTRÊMES
    // ============================================================================
    describe('Extreme Auth Service Responses', () => {
        it('should handle extremely large user objects', async () => {
            // Arrange
            const token = 'valid-token';
            const largeUser = createExtremeUser('maximal');
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: {
                    valid: true,
                    user: largeUser,
                    expiresAt: new Date(Date.now() + 3600000).toISOString(),
                },
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act
            const result = await authGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            expect(request.user).toEqual(largeUser);
            expect(cacheService.set).toHaveBeenCalledWith(expect.any(String), largeUser, expect.any(Number));
        });
        it('should handle user with unicode data', async () => {
            // Arrange
            const token = 'valid-token';
            const unicodeUser = createExtremeUser('unicode');
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: {
                    valid: true,
                    user: unicodeUser,
                    expiresAt: new Date(Date.now() + 3600000).toISOString(),
                },
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act
            const result = await authGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            expect(request.user).toEqual(unicodeUser);
        });
        it('should handle auth service returning non-JSON data', async () => {
            // Arrange
            const token = 'valid-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: 'This is not JSON',
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
        });
        it('should handle auth service returning null data', async () => {
            // Arrange
            const token = 'valid-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: null,
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
        });
        it('should handle auth service returning undefined data', async () => {
            // Arrange
            const token = 'valid-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: undefined,
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
        });
        it('should handle auth service returning circular JSON', async () => {
            // Arrange
            const token = 'valid-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            const circularData = { valid: true };
            circularData.self = circularData;
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: circularData,
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow();
        });
        it('should handle auth service with non-standard HTTP status', async () => {
            // Arrange
            const token = 'valid-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            // Statuts HTTP non-standard
            const unusualStatuses = [299, 418, 451, 599];
            for (const status of unusualStatuses) {
                httpService.post.mockReturnValue((0, rxjs_1.of)({
                    data: { valid: true, user: createExtremeUser('minimal') },
                    status,
                    statusText: `Unusual Status ${status}`,
                    headers: {},
                    config: {},
                }));
                // Act
                if (status >= 200 && status < 300) {
                    const result = await authGuard.canActivate(context);
                    expect(result).toBe(true);
                }
                else {
                    // Pour les status non-2xx, s'attendre à une erreur
                    await expect(authGuard.canActivate(context)).rejects.toThrow();
                }
            }
        });
    });
    // ============================================================================
    // TESTS - CACHE EXTRÊME
    // ============================================================================
    describe('Extreme Cache Cases', () => {
        it('should handle cache returning corrupted data', async () => {
            // Arrange
            const token = 'valid-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            const corruptedData = {
                id: null,
                email: undefined,
                roles: 'not-an-array',
                __proto__: { malicious: true },
            };
            cacheService.get.mockResolvedValue(corruptedData);
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: {
                    valid: true,
                    user: createExtremeUser('minimal'),
                    expiresAt: new Date(Date.now() + 3600000).toISOString(),
                },
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act
            const result = await authGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            // Le guard doit ignorer les données corrompues et faire appel au service
            expect(httpService.post).toHaveBeenCalled();
        });
        it('should handle cache returning extremely large objects', async () => {
            // Arrange
            const token = 'valid-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            const hugeUser = createExtremeUser('maximal');
            cacheService.get.mockResolvedValue(hugeUser);
            // Act
            const result = await authGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            expect(request.user).toEqual(hugeUser);
            expect(httpService.post).not.toHaveBeenCalled();
        });
        it('should handle cache timeouts gracefully', async () => {
            // Arrange
            const token = 'valid-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            // Simuler un timeout de cache (promise qui ne se résout jamais)
            cacheService.get.mockReturnValue(new Promise(() => { })); // Never resolves
            const user = createExtremeUser('minimal');
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: {
                    valid: true,
                    user,
                    expiresAt: new Date(Date.now() + 3600000).toISOString(),
                },
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act - Avec un timeout pour le test
            const result = await Promise.race([
                authGuard.canActivate(context),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Test timeout')), 1000)),
            ]).catch(() => {
                // En cas de timeout, on teste le fallback
                cacheService.get.mockResolvedValue(null);
                return authGuard.canActivate(context);
            });
            // Assert
            expect(result).toBe(true);
        });
        it('should handle cache returning functions or objects with methods', async () => {
            // Arrange
            const token = 'valid-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            const maliciousObject = {
                id: 'user-123',
                email: 'test@example.com',
                roles: ['user'],
                maliciousMethod: () => 'hacked',
                valueOf: () => 'evil',
                toString: () => 'malicious',
            };
            cacheService.get.mockResolvedValue(maliciousObject);
            // Act
            const result = await authGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            // Vérifier que les méthodes malicieuses ne sont pas exécutées
            const injectedUser = request.user;
            expect(typeof injectedUser.maliciousMethod).toBe('function');
            // Mais l'utilisateur ne devrait pas être en mesure de les exécuter dans le contexte sécurisé
        });
    });
    // ============================================================================
    // TESTS - CONCURRENCE EXTRÊME
    // ============================================================================
    describe('Extreme Concurrency Cases', () => {
        it('should handle simultaneous requests with same token gracefully', async () => {
            // Arrange
            const token = 'concurrent-token';
            const user = createExtremeUser('minimal');
            let authServiceCallCount = 0;
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockImplementation(() => {
                authServiceCallCount++;
                return (0, rxjs_1.of)({
                    data: {
                        valid: true,
                        user,
                        expiresAt: new Date(Date.now() + 3600000).toISOString(),
                    },
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
            });
            // Act - 1000 requêtes simultanées avec le même token
            const promises = Array.from({ length: 1000 }, async () => {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                return authGuard.canActivate(context);
            });
            const results = await Promise.all(promises);
            // Assert
            expect(results.every(result => result === true)).toBe(true);
            // Sans déduplication, chaque requête fait un appel
            // Dans une vraie implémentation, on pourrait optimiser cela
            expect(authServiceCallCount).toBe(1000);
        });
        it('should handle race conditions between cache operations', async () => {
            // Arrange
            const token = 'race-token';
            const user = createExtremeUser('minimal');
            let cacheGetCallCount = 0;
            let cacheSetCallCount = 0;
            cacheService.get.mockImplementation(() => {
                cacheGetCallCount++;
                // Simuler une race condition
                if (cacheGetCallCount === 1) {
                    return Promise.resolve(null); // Premier appel: cache miss
                }
                return Promise.resolve(user); // Appels suivants: cache hit
            });
            cacheService.set.mockImplementation(() => {
                cacheSetCallCount++;
                return Promise.resolve();
            });
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: {
                    valid: true,
                    user,
                    expiresAt: new Date(Date.now() + 3600000).toISOString(),
                },
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act - Plusieurs requêtes rapides
            const promises = Array.from({ length: 10 }, async () => {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                return authGuard.canActivate(context);
            });
            const results = await Promise.all(promises);
            // Assert
            expect(results.every(result => result === true)).toBe(true);
            expect(cacheGetCallCount).toBeGreaterThanOrEqual(10);
        });
        it('should handle memory pressure during high concurrency', async () => {
            // Arrange
            const user = createExtremeUser('maximal'); // Large user object
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)({
                data: {
                    valid: true,
                    user,
                    expiresAt: new Date(Date.now() + 3600000).toISOString(),
                },
                status: 200,
                statusText: 'OK',
                headers: {},
                config: {},
            }));
            // Act - Beaucoup de requêtes avec de gros objets
            const promises = Array.from({ length: 100 }, async (_, i) => {
                const token = `memory-pressure-token-${i}`;
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                return authGuard.canActivate(context);
            });
            const results = await Promise.all(promises);
            // Assert
            expect(results.every(result => result === true)).toBe(true);
            expect(cacheService.set).toHaveBeenCalledTimes(100);
        });
    });
    // ============================================================================
    // TESTS - ÉCHECS SYSTÈME EXTRÊMES
    // ============================================================================
    describe('Extreme System Failures', () => {
        it('should handle complete system resource exhaustion', async () => {
            // Arrange
            const token = 'resource-exhaustion-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            // Simuler épuisement des ressources
            cacheService.get.mockRejectedValue(new Error('Out of memory'));
            httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new Error('No file descriptors available')));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow();
        });
        it('should handle network partitioning', async () => {
            // Arrange
            const token = 'network-partition-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new Error('Network is unreachable')));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.ServiceUnavailableException);
        });
        it('should handle DNS resolution failures', async () => {
            // Arrange
            const token = 'dns-failure-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new Error('getaddrinfo ENOTFOUND')));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.ServiceUnavailableException);
        });
        it('should handle TLS/SSL certificate errors', async () => {
            // Arrange
            const token = 'ssl-error-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new Error('certificate verify failed')));
            // Act & Assert
            await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.ServiceUnavailableException);
        });
        it('should handle unexpected Observable behaviors', async () => {
            // Arrange
            const token = 'observable-edge-token';
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            // Test différents comportements d'Observable
            const observableCases = [
                rxjs_1.EMPTY, // Observable qui complete immédiatement sans émettre
                rxjs_1.NEVER, // Observable qui ne complete jamais
                (0, rxjs_1.throwError)(() => new Error('Immediate error')),
            ];
            for (const obs of observableCases) {
                httpService.post.mockReturnValue(obs);
                // Act & Assert
                await expect(authGuard.canActivate(context)).rejects.toThrow();
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL25pY29sYXNiZXJuYXJkL0Rlc2t0b3AvcHJvamVjdC1zZXJ2aWNlL3Rlc3QvdW5pdC9jb21tb24vZ3VhcmRzL2F1dGguZ3VhcmQuZWRnZS1jYXNlcy5zcGVjLnRzIiwibWFwcGluZ3MiOiI7QUFBQSx3REFBd0Q7O0FBRXhELDJDQUFzRztBQUN0RywyQ0FBK0M7QUFDL0MseUNBQTRDO0FBQzVDLDZDQUFzRDtBQUN0RCwrQkFBb0Q7QUFDcEQsaUNBQWtEO0FBRWxELHlFQUFxRTtBQUNyRSx1RUFBbUU7QUFHbkUsUUFBUSxDQUFDLHdCQUF3QixFQUFFLEdBQUcsRUFBRTtJQUN0QyxJQUFJLFNBQW9CLENBQUM7SUFDekIsSUFBSSxhQUF5QyxDQUFDO0lBQzlDLElBQUksWUFBdUMsQ0FBQztJQUM1QyxJQUFJLFdBQXFDLENBQUM7SUFFMUMsK0VBQStFO0lBQy9FLDJDQUEyQztJQUMzQywrRUFBK0U7SUFFL0UsTUFBTSwwQkFBMEIsR0FBRyxDQUFDLE9BQVksRUFBb0IsRUFBRTtRQUNwRSxPQUFPO1lBQ0wsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQ25CLFVBQVUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPO2dCQUN6QixXQUFXLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtnQkFDdEIsT0FBTyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7YUFDbkIsQ0FBQztZQUNGLFdBQVcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3RCLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNO1lBQ3JCLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ25CLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2xCLGFBQWEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ0wsQ0FBQztJQUN4QixDQUFDLENBQUM7SUFFRixN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LENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsb0NBQTJCLENBQUMsQ0FBQztRQUM1RixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQywrQ0FBK0MsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM3RCxVQUFVO1lBQ1YsTUFBTSxLQUFLLEdBQUcsdUJBQXVCLENBQUM7WUFDdEMsTUFBTSxPQUFPLEdBQUcsRUFBRSxPQUFPLEVBQUUsRUFBRSxhQUFhLEVBQUUsVUFBVSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUM7WUFDbEUsTUFBTSxPQUFPLEdBQUcsMEJBQTBCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFcEQsWUFBWSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUV6Qyw2Q0FBNkM7WUFDN0MsTUFBTSxlQUFlLEdBQUc7Z0JBQ3RCLFlBQUssRUFBRSxxREFBcUQ7Z0JBQzVELFlBQUssRUFBRSxvQ0FBb0M7Z0JBQzNDLElBQUEsaUJBQVUsRUFBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2FBQy9DLENBQUM7WUFFRixLQUFLLE1BQU0sR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDO2dCQUNsQyxXQUFXLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFVLENBQUMsQ0FBQztnQkFFN0MsZUFBZTtnQkFDZixNQUFNLE1BQU0sQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2pFLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL25pY29sYXNiZXJuYXJkL0Rlc2t0b3AvcHJvamVjdC1zZXJ2aWNlL3Rlc3QvdW5pdC9jb21tb24vZ3VhcmRzL2F1dGguZ3VhcmQuZWRnZS1jYXNlcy5zcGVjLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRlc3QvdW5pdC9jb21tb24vZ3VhcmRzL2F1dGguZ3VhcmQuZWRnZS1jYXNlcy5zcGVjLnRzXG5cbmltcG9ydCB7IEV4ZWN1dGlvbkNvbnRleHQsIFVuYXV0aG9yaXplZEV4Y2VwdGlvbiwgU2VydmljZVVuYXZhaWxhYmxlRXhjZXB0aW9uIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0BuZXN0anMvY29uZmlnJztcbmltcG9ydCB7IEh0dHBTZXJ2aWNlIH0gZnJvbSAnQG5lc3Rqcy9heGlvcyc7XG5pbXBvcnQgeyBUZXN0LCBUZXN0aW5nTW9kdWxlIH0gZnJvbSAnQG5lc3Rqcy90ZXN0aW5nJztcbmltcG9ydCB7IG9mLCB0aHJvd0Vycm9yLCBORVZFUiwgRU1QVFkgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEF4aW9zUmVzcG9uc2UsIEF4aW9zRXJyb3IgfSBmcm9tICdheGlvcyc7XG5cbmltcG9ydCB7IEF1dGhHdWFyZCB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9jb21tb24vZ3VhcmRzL2F1dGguZ3VhcmQnO1xuaW1wb3J0IHsgQ2FjaGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NhY2hlL2NhY2hlLnNlcnZpY2UnO1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9jb21tb24vaW50ZXJmYWNlcy91c2VyLmludGVyZmFjZSc7XG5cbmRlc2NyaWJlKCdBdXRoR3VhcmQgLSBFZGdlIENhc2VzJywgKCkgPT4ge1xuICBsZXQgYXV0aEd1YXJkOiBBdXRoR3VhcmQ7XG4gIGxldCBjb25maWdTZXJ2aWNlOiBqZXN0Lk1vY2tlZDxDb25maWdTZXJ2aWNlPjtcbiAgbGV0IGNhY2hlU2VydmljZTogamVzdC5Nb2NrZWQ8Q2FjaGVTZXJ2aWNlPjtcbiAgbGV0IGh0dHBTZXJ2aWNlOiBqZXN0Lk1vY2tlZDxIdHRwU2VydmljZT47XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBIRUxQRVJTIFNQw4lDSUFMSVPDiVMgUE9VUiBMRVMgQ0FTIExJTUlURVNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGNvbnN0IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0ID0gKHJlcXVlc3Q6IGFueSk6IEV4ZWN1dGlvbkNvbnRleHQgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzd2l0Y2hUb0h0dHA6ICgpID0+ICh7XG4gICAgICAgIGdldFJlcXVlc3Q6ICgpID0+IHJlcXVlc3QsXG4gICAgICAgIGdldFJlc3BvbnNlOiBqZXN0LmZuKCksXG4gICAgICAgIGdldE5leHQ6IGplc3QuZm4oKSxcbiAgICAgIH0pLFxuICAgICAgc3dpdGNoVG9ScGM6IGplc3QuZm4oKSxcbiAgICAgIHN3aXRjaFRvV3M6IGplc3QuZm4oKSxcbiAgICAgIGdldFR5cGU6ICgpID0+ICdodHRwJyxcbiAgICAgIGdldENsYXNzOiBqZXN0LmZuKCksXG4gICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICBnZXRBcmdzOiBqZXN0LmZuKCksXG4gICAgICBnZXRBcmdCeUluZGV4OiBqZXN0LmZuKCksXG4gICAgfSBhcyBFeGVjdXRpb25Db250ZXh0O1xuICB9O1xuXG4gIGNvbnN0IGNyZWF0ZUV4dHJlbWVVc2VyID0gKHR5cGU6ICdtaW5pbWFsJyB8ICdtYXhpbWFsJyB8ICd1bmljb2RlJyB8ICdudW1lcmljJyk6IFVzZXIgPT4ge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnbWluaW1hbCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6ICdhJyxcbiAgICAgICAgICBlbWFpbDogJ2FAYi5jJyxcbiAgICAgICAgICByb2xlczogWydyJ10sXG4gICAgICAgIH07XG4gICAgICBjYXNlICdtYXhpbWFsJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogJ3VzZXItJyArICd4Jy5yZXBlYXQoMTAwMCksXG4gICAgICAgICAgZW1haWw6ICd2ZXJ5LWxvbmctZW1haWwtYWRkcmVzcy0nICsgJ3gnLnJlcGVhdCgyMDApICsgJ0B2ZXJ5LWxvbmctZG9tYWluLW5hbWUtJyArICd4Jy5yZXBlYXQoMTAwKSArICcuZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHJvbGVzOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGkpID0+IGByb2xlLSR7aX0tJHsneCcucmVwZWF0KDUwKX1gKSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3VuaWNvZGUnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiAn55So5oi3LTEyMy3Osc6yzrMt8J+agCcsXG4gICAgICAgICAgZW1haWw6ICfRgtC10YHRgkDQv9GA0LjQvNC10YAu0YDRhCcsXG4gICAgICAgICAgcm9sZXM6IFsn55So5oi3JywgJ860zrnOsc+HzrXOuc+BzrnPg8+Ezq7PgicsICfwn5SQLWFkbWluJ10sXG4gICAgICAgIH07XG4gICAgICBjYXNlICdudW1lcmljJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogJzEyMzQ1Njc4OScsXG4gICAgICAgICAgZW1haWw6ICcxMjNANDU2Ljc4OScsXG4gICAgICAgICAgcm9sZXM6IFsnMCcsICcxJywgJzInXSxcbiAgICAgICAgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB1c2VyIHR5cGUnKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY3JlYXRlTWFsZm9ybWVkVG9rZW5zID0gKCk6IHN0cmluZ1tdID0+IFtcbiAgICAnJywgLy8gRW1wdHlcbiAgICAnICcsIC8vIFNwYWNlIG9ubHlcbiAgICAnXFx0JywgLy8gVGFiXG4gICAgJ1xcbicsIC8vIE5ld2xpbmVcbiAgICAndG9rZW4gd2l0aCBzcGFjZXMnLFxuICAgICd0b2tlblxcbndpdGhcXG5uZXdsaW5lcycsXG4gICAgJ3Rva2VuXFx0d2l0aFxcdHRhYnMnLFxuICAgICd0b2tlbi53aXRoLm9ubHkudHdvLnBhcnRzJyxcbiAgICAndG9rZW4ud2l0aC50b28ubWFueS5wYXJ0cy5oZXJlLmFuZC5oZXJlJyxcbiAgICAndG9rZTEyMycsXG4gICAgJy4uLi4uLicsXG4gICAgJ0JlYXJlciB0b2tlbicsIC8vIERvdWJsZSBCZWFyZXJcbiAgICAnYScucmVwZWF0KDEwMDAwKSwgLy8gVHLDqHMgbG9uZ1xuICAgICdcXHUwMDAwdG9rZW5cXHUwMDAwJywgLy8gTnVsbCBieXRlc1xuICAgICd0b2tlbvCfmoB3aXRo8J+UkGVtb2ppcycsXG4gICAgJ3Rva2VuLXdpdGgtdW5pY29kZS3Osc6yzrMtY2hhcmFjdGVycycsXG4gIF07XG5cbiAgY29uc3QgY3JlYXRlQm91bmRhcnlWYWx1ZXMgPSAoKSA9PiAoe1xuICAgIGxhcmdlTnVtYmVyczogW1xuICAgICAgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgIE51bWJlci5NQVhfVkFMVUUsXG4gICAgICBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgSW5maW5pdHksXG4gICAgICAtSW5maW5pdHksXG4gICAgXSxcbiAgICBzcGVjaWFsU3RyaW5nczogW1xuICAgICAgJycsXG4gICAgICAnICcsXG4gICAgICAnICAnLFxuICAgICAgJ1xcbicsXG4gICAgICAnXFxyJyxcbiAgICAgICdcXHQnLFxuICAgICAgJ1xcclxcbicsXG4gICAgICAnXFwwJyxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMCksXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTM1KSxcbiAgICAgICdcXFxcJyxcbiAgICAgICcvJyxcbiAgICAgICdcIicsXG4gICAgICBcIidcIixcbiAgICAgICdgJyxcbiAgICAgICckJyxcbiAgICAgICclJyxcbiAgICAgICcmJyxcbiAgICAgICc8c2NyaXB0PicsXG4gICAgICAnU0VMRUNUICogRlJPTSB1c2VycycsXG4gICAgICAnLi4vLi4vLi4vZXRjL3Bhc3N3ZCcsXG4gICAgICAnQzpcXFxcV2luZG93c1xcXFxTeXN0ZW0zMicsXG4gICAgXSxcbiAgICBlZGdlRGF0ZXM6IFtcbiAgICAgIG5ldyBEYXRlKDApLCAvLyBVbml4IGVwb2NoXG4gICAgICBuZXcgRGF0ZSgnMTk3MC0wMS0wMVQwMDowMDowMC4wMDBaJyksXG4gICAgICBuZXcgRGF0ZSgnMjAzOC0wMS0xOVQwMzoxNDowNy4wMDBaJyksIC8vIDMyLWJpdCB0aW1lc3RhbXAgbGltaXRcbiAgICAgIG5ldyBEYXRlKCc5OTk5LTEyLTMxVDIzOjU5OjU5Ljk5OVonKSxcbiAgICAgIG5ldyBEYXRlKCdJbnZhbGlkIERhdGUnKSxcbiAgICBdLFxuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNFVFVQXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2R1bGU6IFRlc3RpbmdNb2R1bGUgPSBhd2FpdCBUZXN0LmNyZWF0ZVRlc3RpbmdNb2R1bGUoe1xuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIEF1dGhHdWFyZCxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IENvbmZpZ1NlcnZpY2UsXG4gICAgICAgICAgdXNlVmFsdWU6IHtcbiAgICAgICAgICAgIGdldDogamVzdC5mbigpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBDYWNoZVNlcnZpY2UsXG4gICAgICAgICAgdXNlVmFsdWU6IHtcbiAgICAgICAgICAgIGdldDogamVzdC5mbigpLFxuICAgICAgICAgICAgc2V0OiBqZXN0LmZuKCksXG4gICAgICAgICAgICBkZWw6IGplc3QuZm4oKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogSHR0cFNlcnZpY2UsXG4gICAgICAgICAgdXNlVmFsdWU6IHtcbiAgICAgICAgICAgIHBvc3Q6IGplc3QuZm4oKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KS5jb21waWxlKCk7XG5cbiAgICBhdXRoR3VhcmQgPSBtb2R1bGUuZ2V0PEF1dGhHdWFyZD4oQXV0aEd1YXJkKTtcbiAgICBjb25maWdTZXJ2aWNlID0gbW9kdWxlLmdldChDb25maWdTZXJ2aWNlKTtcbiAgICBjYWNoZVNlcnZpY2UgPSBtb2R1bGUuZ2V0KENhY2hlU2VydmljZSk7XG4gICAgaHR0cFNlcnZpY2UgPSBtb2R1bGUuZ2V0KEh0dHBTZXJ2aWNlKTtcblxuICAgIGNvbmZpZ1NlcnZpY2UuZ2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ0FVVEhfU0VSVklDRV9VUkwnOlxuICAgICAgICAgIHJldHVybiAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcbiAgICAgICAgY2FzZSAnQVVUSF9TRVJWSUNFX1RJTUVPVVQnOlxuICAgICAgICAgIHJldHVybiAnNTAwMCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHByb2Nlc3MuZW52LkFVVEhfU0VSVklDRV9VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcbiAgICBwcm9jZXNzLmVudi5BVVRIX1NFUlZJQ0VfVElNRU9VVCA9ICc1MDAwJztcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBqZXN0LnJlc3RvcmVBbGxNb2NrcygpO1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRFU1RTIC0gVE9LRU5TIEVYVFLDik1FU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZGVzY3JpYmUoJ0V4dHJlbWUgVG9rZW4gQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgYW5kIHdoaXRlc3BhY2UgdG9rZW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgaW52YWxpZFRva2VucyA9IFsnJywgJyAnLCAnXFx0JywgJ1xcbicsICdcXHJcXG4nLCAnICAgJ107XG5cbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgaW52YWxpZFRva2Vucykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coVW5hdXRob3JpemVkRXhjZXB0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV4dHJlbWVseSBsb25nIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHZlcnlMb25nVG9rZW4gPSAnYScucmVwZWF0KDEwMDAwMCk7IC8vIDEwMEtCIHRva2VuXG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt2ZXJ5TG9uZ1Rva2VufWAgfSB9O1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBuZXcgQXhpb3NFcnJvcignUmVxdWVzdCB0b28gbGFyZ2UnLCAnNDEzJykpKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRva2VucyB3aXRoIHNwZWNpYWwgY2hhcmFjdGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHNwZWNpYWxUb2tlbnMgPSBjcmVhdGVNYWxmb3JtZWRUb2tlbnMoKTtcblxuICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBzcGVjaWFsVG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBuZXcgQXhpb3NFcnJvcignSW52YWxpZCB0b2tlbicsICc0MDAnKSkpO1xuXG4gICAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRva2VucyB3aXRoIHVuaWNvZGUgY2hhcmFjdGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHVuaWNvZGVUb2tlbnMgPSBbXG4gICAgICAgICfRgtC10YHRgi7RgtC+0LrQtdC9LtC/0L7QtNC/0LjRgdGMJyxcbiAgICAgICAgJ+ODhuOCueODiC7jg4jjg7zjgq/jg7Mu572y5ZCNJyxcbiAgICAgICAgJ+a1i+ivlS7ku6TniYwu562+5ZCNJyxcbiAgICAgICAgJ3Rlc3Qu8J+agC5zaWduYXR1cmUnLFxuICAgICAgICAndG9rZW4ud2l0aC7Osc6yzrMuY2hhcmFjdGVycycsXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHVuaWNvZGVUb2tlbnMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG5ldyBBeGlvc0Vycm9yKCdJbnZhbGlkIHRva2VuJywgJzQwMCcpKSk7XG5cbiAgICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdG9rZW5zIHdpdGggbnVsbCBieXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG51bGxCeXRlVG9rZW5zID0gW1xuICAgICAgICAndG9rZW5cXHgwMHdpdGhcXHgwMG51bGxzJyxcbiAgICAgICAgJ1xceDAwdG9rZW4nLFxuICAgICAgICAndG9rZW5cXHgwMCcsXG4gICAgICAgICdiZWZvcmVcXHgwMG51bGxcXHgwMGFmdGVyJyxcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbnVsbEJ5dGVUb2tlbnMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgICAgYXdhaXQgZXhwZWN0KGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KSkucmVqZWN0cy50b1Rocm93KFVuYXV0aG9yaXplZEV4Y2VwdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtYWxmb3JtZWQgSldUIHN0cnVjdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1hbGZvcm1lZEpXVHMgPSBbXG4gICAgICAgICdoZWFkZXInLCAvLyBPbmx5IG9uZSBwYXJ0XG4gICAgICAgICdoZWFkZXIucGF5bG9hZCcsIC8vIE9ubHkgdHdvIHBhcnRzXG4gICAgICAgICdoZWFkZXIucGF5bG9hZC5zaWduYXR1cmUuZXh0cmEnLCAvLyBUb28gbWFueSBwYXJ0c1xuICAgICAgICAnLnBheWxvYWQuc2lnbmF0dXJlJywgLy8gRW1wdHkgaGVhZGVyXG4gICAgICAgICdoZWFkZXIuLnNpZ25hdHVyZScsIC8vIEVtcHR5IHBheWxvYWRcbiAgICAgICAgJ2hlYWRlci5wYXlsb2FkLicsIC8vIEVtcHR5IHNpZ25hdHVyZVxuICAgICAgICAnLi4nLCAvLyBBbGwgZW1wdHlcbiAgICAgICAgJ2hlYWRlci5wYXlsb2FkLnNpZ25hdHVyZS4nLCAvLyBUcmFpbGluZyBkb3RcbiAgICAgICAgJy5oZWFkZXIucGF5bG9hZC5zaWduYXR1cmUnLCAvLyBMZWFkaW5nIGRvdFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBqd3Qgb2YgbWFsZm9ybWVkSldUcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtqd3R9YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG5ldyBBeGlvc0Vycm9yKCdNYWxmb3JtZWQgSldUJywgJzQwMCcpKSk7XG5cbiAgICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRFU1RTIC0gSEVBREVSUyBFWFRSw4pNRVNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGRlc2NyaWJlKCdFeHRyZW1lIEhlYWRlciBDYXNlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBoZWFkZXJzIHdpdGggZGlmZmVyZW50IGNhc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgaGVhZGVyVmFyaWF0aW9ucyA9IFtcbiAgICAgICAgJ2F1dGhvcml6YXRpb24nLFxuICAgICAgICAnQXV0aG9yaXphdGlvbicsXG4gICAgICAgICdBVVRIT1JJWkFUSU9OJyxcbiAgICAgICAgJ0F1VGhPckl6QXRJb04nLFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIGhlYWRlclZhcmlhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgW2hlYWRlck5hbWVdOiAnQmVhcmVyIHZhbGlkLXRva2VuJyB9O1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzIH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG5ldyBBeGlvc0Vycm9yKCdJbnZhbGlkJywgJzQwMScpKSk7XG5cbiAgICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICAgIC8vIExlIGJlaGF2aW9yIHBldXQgdmFyaWVyIHNlbG9uIGwnaW1wbMOpbWVudGF0aW9uXG4gICAgICAgIC8vIExhIHBsdXBhcnQgZGVzIHNlcnZldXJzIG5vcm1hbGlzZW50IGxlcyBoZWFkZXJzXG4gICAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgYXV0aG9yaXphdGlvbiBoZWFkZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGF1dGhvcml6YXRpb246IFsnQmVhcmVyIHRva2VuMScsICdCZWFyZXIgdG9rZW4yJ10sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdyhVbmF1dGhvcml6ZWRFeGNlcHRpb24pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXh0cmVtZWx5IGxhcmdlIGhlYWRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBsYXJnZVRva2VuID0gJ3Rva2VuJyArICd4Jy5yZXBlYXQoNTAwMDApO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGF1dGhvcml6YXRpb246ICdCZWFyZXIgdG9rZW4xJywgLy8gVW5lIHNldWxlIHZhbGV1ciBhdSBsaWV1IGQndW4gYXJyYXlcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG5ldyBFcnJvcignSGVhZGVycyB0b28gbGFyZ2UnKSkpO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaGVhZGVycyB3aXRoIHNwZWNpYWwgY2hhcmFjdGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBhdXRob3JpemF0aW9uOiAnQmVhcmVyIHZhbGlkLXRva2VuJyxcbiAgICAgICAgICAneC1zcGVjaWFsJzogJ3ZhbHVlXFxyXFxuSW5qZWN0ZWQ6IGhlYWRlcicsXG4gICAgICAgICAgJ3gtdW5pY29kZSc6ICfRgtC10YHRgi3Qt9C90LDRh9C10L3QuNC1LfCfmoAnLFxuICAgICAgICAgICd4LW51bGwnOiAndmFsdWVcXHgwMHdpdGhcXHgwMG51bGxzJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVFeHRyZW1lVXNlcignbWluaW1hbCcpO1xuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh1c2VyKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIC8vIExlIGd1YXJkIGRvaXQgc2FuaXRpemVyIGxlcyBoZWFkZXJzIGF2YW50IGRlIGxlcyB1dGlsaXNlclxuICAgIH0pO1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRFU1RTIC0gUsOJUE9OU0VTIERVIFNFUlZJQ0UgRCdBVVRIIEVYVFLDik1FU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZGVzY3JpYmUoJ0V4dHJlbWUgQXV0aCBTZXJ2aWNlIFJlc3BvbnNlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBleHRyZW1lbHkgbGFyZ2UgdXNlciBvYmplY3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSAndmFsaWQtdG9rZW4nO1xuICAgICAgY29uc3QgbGFyZ2VVc2VyID0gY3JlYXRlRXh0cmVtZVVzZXIoJ21heGltYWwnKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2Yoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgdXNlcjogbGFyZ2VVc2VyLFxuICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM2MDAwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoKHJlcXVlc3QgYXMgYW55KS51c2VyKS50b0VxdWFsKGxhcmdlVXNlcik7XG4gICAgICBleHBlY3QoY2FjaGVTZXJ2aWNlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgbGFyZ2VVc2VyLFxuICAgICAgICBleHBlY3QuYW55KE51bWJlcilcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1c2VyIHdpdGggdW5pY29kZSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSAndmFsaWQtdG9rZW4nO1xuICAgICAgY29uc3QgdW5pY29kZVVzZXIgPSBjcmVhdGVFeHRyZW1lVXNlcigndW5pY29kZScpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZih7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICB1c2VyOiB1bmljb2RlVXNlcixcbiAgICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAzNjAwMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KChyZXF1ZXN0IGFzIGFueSkudXNlcikudG9FcXVhbCh1bmljb2RlVXNlcik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBhdXRoIHNlcnZpY2UgcmV0dXJuaW5nIG5vbi1KU09OIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9ICd2YWxpZC10b2tlbic7XG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKHtcbiAgICAgICAgZGF0YTogJ1RoaXMgaXMgbm90IEpTT04nLFxuICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdyhVbmF1dGhvcml6ZWRFeGNlcHRpb24pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXV0aCBzZXJ2aWNlIHJldHVybmluZyBudWxsIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9ICd2YWxpZC10b2tlbic7XG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcbiAgICAgIH0pKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coVW5hdXRob3JpemVkRXhjZXB0aW9uKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGF1dGggc2VydmljZSByZXR1cm5pbmcgdW5kZWZpbmVkIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9ICd2YWxpZC10b2tlbic7XG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKHtcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdyhVbmF1dGhvcml6ZWRFeGNlcHRpb24pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXV0aCBzZXJ2aWNlIHJldHVybmluZyBjaXJjdWxhciBKU09OJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSAndmFsaWQtdG9rZW4nO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIGNvbnN0IGNpcmN1bGFyRGF0YTogYW55ID0geyB2YWxpZDogdHJ1ZSB9O1xuICAgICAgY2lyY3VsYXJEYXRhLnNlbGYgPSBjaXJjdWxhckRhdGE7XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZih7XG4gICAgICAgIGRhdGE6IGNpcmN1bGFyRGF0YSxcbiAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcbiAgICAgIH0pKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGF1dGggc2VydmljZSB3aXRoIG5vbi1zdGFuZGFyZCBIVFRQIHN0YXR1cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gJ3ZhbGlkLXRva2VuJztcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICAvLyBTdGF0dXRzIEhUVFAgbm9uLXN0YW5kYXJkXG4gICAgICBjb25zdCB1bnVzdWFsU3RhdHVzZXMgPSBbMjk5LCA0MTgsIDQ1MSwgNTk5XTtcblxuICAgICAgZm9yIChjb25zdCBzdGF0dXMgb2YgdW51c3VhbFN0YXR1c2VzKSB7XG4gICAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKHtcbiAgICAgICAgICBkYXRhOiB7IHZhbGlkOiB0cnVlLCB1c2VyOiBjcmVhdGVFeHRyZW1lVXNlcignbWluaW1hbCcpIH0sXG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IGBVbnVzdWFsIFN0YXR1cyAke3N0YXR1c31gLFxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gQWN0XG4gICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBvdXIgbGVzIHN0YXR1cyBub24tMnh4LCBzJ2F0dGVuZHJlIMOgIHVuZSBlcnJldXJcbiAgICAgICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRFU1RTIC0gQ0FDSEUgRVhUUsOKTUVcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGRlc2NyaWJlKCdFeHRyZW1lIENhY2hlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNhY2hlIHJldHVybmluZyBjb3JydXB0ZWQgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gJ3ZhbGlkLXRva2VuJztcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICBjb25zdCBjb3JydXB0ZWREYXRhID0ge1xuICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgZW1haWw6IHVuZGVmaW5lZCxcbiAgICAgICAgcm9sZXM6ICdub3QtYW4tYXJyYXknLFxuICAgICAgICBfX3Byb3RvX186IHsgbWFsaWNpb3VzOiB0cnVlIH0sXG4gICAgICB9O1xuXG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKGNvcnJ1cHRlZERhdGEpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2Yoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgdXNlcjogY3JlYXRlRXh0cmVtZVVzZXIoJ21pbmltYWwnKSxcbiAgICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAzNjAwMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgLy8gTGUgZ3VhcmQgZG9pdCBpZ25vcmVyIGxlcyBkb25uw6llcyBjb3Jyb21wdWVzIGV0IGZhaXJlIGFwcGVsIGF1IHNlcnZpY2VcbiAgICAgIGV4cGVjdChodHRwU2VydmljZS5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjYWNoZSByZXR1cm5pbmcgZXh0cmVtZWx5IGxhcmdlIG9iamVjdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9ICd2YWxpZC10b2tlbic7XG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgY29uc3QgaHVnZVVzZXIgPSBjcmVhdGVFeHRyZW1lVXNlcignbWF4aW1hbCcpO1xuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShodWdlVXNlcik7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoKHJlcXVlc3QgYXMgYW55KS51c2VyKS50b0VxdWFsKGh1Z2VVc2VyKTtcbiAgICAgIGV4cGVjdChodHRwU2VydmljZS5wb3N0KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FjaGUgdGltZW91dHMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gJ3ZhbGlkLXRva2VuJztcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICAvLyBTaW11bGVyIHVuIHRpbWVvdXQgZGUgY2FjaGUgKHByb21pc2UgcXVpIG5lIHNlIHLDqXNvdXQgamFtYWlzKVxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmV0dXJuVmFsdWUobmV3IFByb21pc2UoKCkgPT4ge30pKTsgLy8gTmV2ZXIgcmVzb2x2ZXNcbiAgICAgIFxuICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZUV4dHJlbWVVc2VyKCdtaW5pbWFsJyk7XG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZih7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICB1c2VyLFxuICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM2MDAwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIEFjdCAtIEF2ZWMgdW4gdGltZW91dCBwb3VyIGxlIHRlc3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KSxcbiAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdUZXN0IHRpbWVvdXQnKSksIDEwMDApXG4gICAgICAgICksXG4gICAgICBdKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8vIEVuIGNhcyBkZSB0aW1lb3V0LCBvbiB0ZXN0ZSBsZSBmYWxsYmFja1xuICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICByZXR1cm4gYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNhY2hlIHJldHVybmluZyBmdW5jdGlvbnMgb3Igb2JqZWN0cyB3aXRoIG1ldGhvZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9ICd2YWxpZC10b2tlbic7XG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgY29uc3QgbWFsaWNpb3VzT2JqZWN0ID0ge1xuICAgICAgICBpZDogJ3VzZXItMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZXM6IFsndXNlciddLFxuICAgICAgICBtYWxpY2lvdXNNZXRob2Q6ICgpID0+ICdoYWNrZWQnLFxuICAgICAgICB2YWx1ZU9mOiAoKSA9PiAnZXZpbCcsXG4gICAgICAgIHRvU3RyaW5nOiAoKSA9PiAnbWFsaWNpb3VzJyxcbiAgICAgIH07XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobWFsaWNpb3VzT2JqZWN0KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIC8vIFbDqXJpZmllciBxdWUgbGVzIG3DqXRob2RlcyBtYWxpY2lldXNlcyBuZSBzb250IHBhcyBleMOpY3V0w6llc1xuICAgICAgY29uc3QgaW5qZWN0ZWRVc2VyID0gKHJlcXVlc3QgYXMgYW55KS51c2VyO1xuICAgICAgZXhwZWN0KHR5cGVvZiBpbmplY3RlZFVzZXIubWFsaWNpb3VzTWV0aG9kKS50b0JlKCdmdW5jdGlvbicpO1xuICAgICAgLy8gTWFpcyBsJ3V0aWxpc2F0ZXVyIG5lIGRldnJhaXQgcGFzIMOqdHJlIGVuIG1lc3VyZSBkZSBsZXMgZXjDqWN1dGVyIGRhbnMgbGUgY29udGV4dGUgc8OpY3VyaXPDqVxuICAgIH0pO1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRFU1RTIC0gQ09OQ1VSUkVOQ0UgRVhUUsOKTUVcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGRlc2NyaWJlKCdFeHRyZW1lIENvbmN1cnJlbmN5IENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNpbXVsdGFuZW91cyByZXF1ZXN0cyB3aXRoIHNhbWUgdG9rZW4gZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gJ2NvbmN1cnJlbnQtdG9rZW4nO1xuICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZUV4dHJlbWVVc2VyKCdtaW5pbWFsJyk7XG5cbiAgICAgIGxldCBhdXRoU2VydmljZUNhbGxDb3VudCA9IDA7XG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBhdXRoU2VydmljZUNhbGxDb3VudCsrO1xuICAgICAgICByZXR1cm4gb2Yoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM2MDAwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3QgLSAxMDAwIHJlcXXDqnRlcyBzaW11bHRhbsOpZXMgYXZlYyBsZSBtw6ptZSB0b2tlblxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHRzLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQgPT09IHRydWUpKS50b0JlKHRydWUpO1xuICAgICAgLy8gU2FucyBkw6lkdXBsaWNhdGlvbiwgY2hhcXVlIHJlcXXDqnRlIGZhaXQgdW4gYXBwZWxcbiAgICAgIC8vIERhbnMgdW5lIHZyYWllIGltcGzDqW1lbnRhdGlvbiwgb24gcG91cnJhaXQgb3B0aW1pc2VyIGNlbGFcbiAgICAgIGV4cGVjdChhdXRoU2VydmljZUNhbGxDb3VudCkudG9CZSgxMDAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJhY2UgY29uZGl0aW9ucyBiZXR3ZWVuIGNhY2hlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9ICdyYWNlLXRva2VuJztcbiAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVFeHRyZW1lVXNlcignbWluaW1hbCcpO1xuXG4gICAgICBsZXQgY2FjaGVHZXRDYWxsQ291bnQgPSAwO1xuICAgICAgbGV0IGNhY2hlU2V0Q2FsbENvdW50ID0gMDtcblxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjYWNoZUdldENhbGxDb3VudCsrO1xuICAgICAgICAvLyBTaW11bGVyIHVuZSByYWNlIGNvbmRpdGlvblxuICAgICAgICBpZiAoY2FjaGVHZXRDYWxsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpOyAvLyBQcmVtaWVyIGFwcGVsOiBjYWNoZSBtaXNzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1c2VyKTsgLy8gQXBwZWxzIHN1aXZhbnRzOiBjYWNoZSBoaXRcbiAgICAgIH0pO1xuXG4gICAgICBjYWNoZVNlcnZpY2Uuc2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNhY2hlU2V0Q2FsbENvdW50Kys7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZih7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICB1c2VyLFxuICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM2MDAwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIEFjdCAtIFBsdXNpZXVycyByZXF1w6p0ZXMgcmFwaWRlc1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gcmVzdWx0ID09PSB0cnVlKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChjYWNoZUdldENhbGxDb3VudCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgxMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtZW1vcnkgcHJlc3N1cmUgZHVyaW5nIGhpZ2ggY29uY3VycmVuY3knLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB1c2VyID0gY3JlYXRlRXh0cmVtZVVzZXIoJ21heGltYWwnKTsgLy8gTGFyZ2UgdXNlciBvYmplY3RcbiAgICAgIFxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMzYwMDAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcbiAgICAgIH0pKTtcblxuICAgICAgLy8gQWN0IC0gQmVhdWNvdXAgZGUgcmVxdcOqdGVzIGF2ZWMgZGUgZ3JvcyBvYmpldHNcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIGFzeW5jIChfLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gYG1lbW9yeS1wcmVzc3VyZS10b2tlbi0ke2l9YDtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHRzLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQgPT09IHRydWUpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGNhY2hlU2VydmljZS5zZXQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxMDApO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRFU1RTIC0gw4lDSEVDUyBTWVNUw4hNRSBFWFRSw4pNRVNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGRlc2NyaWJlKCdFeHRyZW1lIFN5c3RlbSBGYWlsdXJlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wbGV0ZSBzeXN0ZW0gcmVzb3VyY2UgZXhoYXVzdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gJ3Jlc291cmNlLWV4aGF1c3Rpb24tdG9rZW4nO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIC8vIFNpbXVsZXIgw6lwdWlzZW1lbnQgZGVzIHJlc3NvdXJjZXNcbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdPdXQgb2YgbWVtb3J5JykpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBuZXcgRXJyb3IoJ05vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlJykpKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgcGFydGl0aW9uaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSAnbmV0d29yay1wYXJ0aXRpb24tdG9rZW4nO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG5ldyBFcnJvcignTmV0d29yayBpcyB1bnJlYWNoYWJsZScpKSk7XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgYXdhaXQgZXhwZWN0KGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KSkucmVqZWN0cy50b1Rocm93KFNlcnZpY2VVbmF2YWlsYWJsZUV4Y2VwdGlvbik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBETlMgcmVzb2x1dGlvbiBmYWlsdXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gJ2Rucy1mYWlsdXJlLXRva2VuJztcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBuZXcgRXJyb3IoJ2dldGFkZHJpbmZvIEVOT1RGT1VORCcpKSk7XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgYXdhaXQgZXhwZWN0KGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KSkucmVqZWN0cy50b1Rocm93KFNlcnZpY2VVbmF2YWlsYWJsZUV4Y2VwdGlvbik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBUTFMvU1NMIGNlcnRpZmljYXRlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gJ3NzbC1lcnJvci10b2tlbic7XG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKHRocm93RXJyb3IoKCkgPT4gbmV3IEVycm9yKCdjZXJ0aWZpY2F0ZSB2ZXJpZnkgZmFpbGVkJykpKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coU2VydmljZVVuYXZhaWxhYmxlRXhjZXB0aW9uKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHVuZXhwZWN0ZWQgT2JzZXJ2YWJsZSBiZWhhdmlvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9ICdvYnNlcnZhYmxlLWVkZ2UtdG9rZW4nO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIC8vIFRlc3QgZGlmZsOpcmVudHMgY29tcG9ydGVtZW50cyBkJ09ic2VydmFibGVcbiAgICAgIGNvbnN0IG9ic2VydmFibGVDYXNlcyA9IFtcbiAgICAgICAgRU1QVFksIC8vIE9ic2VydmFibGUgcXVpIGNvbXBsZXRlIGltbcOpZGlhdGVtZW50IHNhbnMgw6ltZXR0cmVcbiAgICAgICAgTkVWRVIsIC8vIE9ic2VydmFibGUgcXVpIG5lIGNvbXBsZXRlIGphbWFpc1xuICAgICAgICB0aHJvd0Vycm9yKCgpID0+IG5ldyBFcnJvcignSW1tZWRpYXRlIGVycm9yJykpLFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBvYnMgb2Ygb2JzZXJ2YWJsZUNhc2VzKSB7XG4gICAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9icyBhcyBhbnkpO1xuXG4gICAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTsiXSwidmVyc2lvbiI6M30=