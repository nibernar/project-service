dad5be3faa7fb7ee42331737a8c1282a
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheService = void 0;
// src/cache/cache.service.ts
const common_1 = require("@nestjs/common");
const ioredis_1 = require("@nestjs-modules/ioredis");
const config_1 = require("@nestjs/config");
const ioredis_2 = require("ioredis");
const cache_config_1 = require("../config/cache.config");
let CacheService = class CacheService {
    redis;
    configService;
    constructor(redis, configService) {
        this.redis = redis;
        this.configService = configService;
    }
    /**
     * Le module @nestjs-modules/ioredis applique automatiquement le préfixe configuré
     * Donc on retourne la clé telle quelle
     */
    getFullKey(key) {
        return key;
    }
    async get(key) {
        try {
            const fullKey = this.getFullKey(key);
            const value = await this.redis.get(fullKey);
            return value ? JSON.parse(value) : null;
        }
        catch (error) {
            console.error(`Cache get error for key ${key}:`, error);
            return null;
        }
    }
    async set(key, value, ttl) {
        try {
            const cacheConfig = (0, cache_config_1.getCacheConfig)(this.configService);
            const finalTtl = ttl !== undefined ? ttl : cacheConfig.performance.defaultTtl;
            const fullKey = this.getFullKey(key);
            await this.redis.setex(fullKey, finalTtl, JSON.stringify(value));
        }
        catch (error) {
            console.error(`Cache set error for key ${key}:`, error);
        }
    }
    async del(key) {
        try {
            if (Array.isArray(key)) {
                if (key.length > 0) {
                    const fullKeys = key.map(k => this.getFullKey(k));
                    await this.redis.del(...fullKeys);
                }
            }
            else {
                const fullKey = this.getFullKey(key);
                await this.redis.del(fullKey);
            }
        }
        catch (error) {
            console.error(`Cache delete error:`, error);
        }
    }
    async invalidateProjectCache(projectId, userId) {
        try {
            const keys = [
                cache_config_1.CACHE_KEYS.PROJECT(projectId),
                cache_config_1.CACHE_KEYS.PROJECT_STATISTICS(projectId),
                cache_config_1.CACHE_KEYS.USER_PROJECTS_COUNT(userId),
            ];
            // Invalider aussi les listes de projets de l'utilisateur
            // Pour keys(), nous devons inclure le préfixe manuellement
            const prefix = this.getKeyPrefix();
            const listPattern = `${prefix}projects:${userId}:*`;
            const listKeys = await this.redis.keys(listPattern);
            // Enlever le préfixe des clés trouvées car del() applique automatiquement le préfixe
            const listKeysWithoutPrefix = listKeys.map(key => key.replace(prefix, ''));
            const allKeysToDelete = [...keys, ...listKeysWithoutPrefix];
            await this.del(allKeysToDelete);
        }
        catch (error) {
            console.error(`Cache delete error:`, error);
        }
    }
    async invalidateUserProjectsCache(userId) {
        try {
            // Rechercher toutes les clés de liste pour cet utilisateur
            // Pour keys(), nous devons inclure le préfixe manuellement
            const prefix = this.getKeyPrefix();
            const listPattern = `${prefix}projects:${userId}:*`;
            const keys = await this.redis.keys(listPattern);
            // Enlever le préfixe des clés trouvées car del() applique automatiquement le préfixe
            const keysWithoutPrefix = keys.map(key => key.replace(prefix, ''));
            if (keysWithoutPrefix.length > 0) {
                await this.del(keysWithoutPrefix);
            }
        }
        catch (error) {
            console.error(`Cache delete error:`, error);
        }
    }
    /**
     * Méthodes utilitaires pour construire les clés de cache
     */
    getProjectKey(projectId) {
        return cache_config_1.CACHE_KEYS.PROJECT(projectId);
    }
    getProjectListKey(userId, page, limit) {
        return cache_config_1.CACHE_KEYS.PROJECT_LIST(userId, page, limit);
    }
    getProjectStatisticsKey(projectId) {
        return cache_config_1.CACHE_KEYS.PROJECT_STATISTICS(projectId);
    }
    getUserProjectsCountKey(userId) {
        return cache_config_1.CACHE_KEYS.USER_PROJECTS_COUNT(userId);
    }
    /**
     * Récupère le préfixe des clés depuis la configuration
     */
    getKeyPrefix() {
        const cacheConfig = (0, cache_config_1.getCacheConfig)(this.configService);
        return cacheConfig.serialization.keyPrefix;
    }
    /**
     * Vérifie si Redis est connecté
     */
    async isConnected() {
        try {
            const result = await this.redis.ping();
            return result === 'PONG';
        }
        catch (error) {
            console.error('Redis connection check failed:', error);
            return false;
        }
    }
    /**
     * Récupère des informations sur Redis
     */
    async getInfo() {
        try {
            return await this.redis.info();
        }
        catch (error) {
            console.error('Redis info failed:', error);
            return '';
        }
    }
    /**
     * Ferme la connexion Redis (utile pour les tests)
     */
    async disconnect() {
        try {
            await this.redis.quit();
        }
        catch (error) {
            console.error('Error closing Redis connection:', error);
        }
    }
};
exports.CacheService = CacheService;
exports.CacheService = CacheService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, ioredis_1.InjectRedis)()),
    __metadata("design:paramtypes", [ioredis_2.default,
        config_1.ConfigService])
], CacheService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL25pY29sYXNiZXJuYXJkL0Rlc2t0b3AvcHJvamVjdC1zZXJ2aWNlL3NyYy9jYWNoZS9jYWNoZS5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZCQUE2QjtBQUM3QiwyQ0FBNEM7QUFDNUMscURBQXNEO0FBQ3RELDJDQUErQztBQUMvQyxxQ0FBNEI7QUFDNUIseURBQStFO0FBR3hFLElBQU0sWUFBWSxHQUFsQixNQUFNLFlBQVk7SUFFVztJQUNmO0lBRm5CLFlBQ2tDLEtBQVksRUFDM0IsYUFBNEI7UUFEYixVQUFLLEdBQUwsS0FBSyxDQUFPO1FBQzNCLGtCQUFhLEdBQWIsYUFBYSxDQUFlO0lBQzVDLENBQUM7SUFFSjs7O09BR0c7SUFDSyxVQUFVLENBQUMsR0FBVztRQUM1QixPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRCxLQUFLLENBQUMsR0FBRyxDQUFJLEdBQVc7UUFDdEIsSUFBSSxDQUFDO1lBQ0gsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyQyxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzVDLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDMUMsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLDJCQUEyQixHQUFHLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN4RCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0lBRUQsS0FBSyxDQUFDLEdBQUcsQ0FBSSxHQUFXLEVBQUUsS0FBUSxFQUFFLEdBQVk7UUFDOUMsSUFBSSxDQUFDO1lBQ0gsTUFBTSxXQUFXLEdBQUcsSUFBQSw2QkFBYyxFQUFDLElBQUksQ0FBQyxhQUFhLENB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LFlBQVksQ0FnS3hCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9uaWNvbGFzYmVybmFyZC9EZXNrdG9wL3Byb2plY3Qtc2VydmljZS9zcmMvY2FjaGUvY2FjaGUuc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY2FjaGUvY2FjaGUuc2VydmljZS50c1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IEluamVjdFJlZGlzIH0gZnJvbSAnQG5lc3Rqcy1tb2R1bGVzL2lvcmVkaXMnO1xuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0BuZXN0anMvY29uZmlnJztcbmltcG9ydCBSZWRpcyBmcm9tICdpb3JlZGlzJztcbmltcG9ydCB7IENBQ0hFX0tFWVMsIENBQ0hFX1RUTCwgZ2V0Q2FjaGVDb25maWcgfSBmcm9tICcuLi9jb25maWcvY2FjaGUuY29uZmlnJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENhY2hlU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3RSZWRpcygpIHByaXZhdGUgcmVhZG9ubHkgcmVkaXM6IFJlZGlzLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnU2VydmljZTogQ29uZmlnU2VydmljZSxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBMZSBtb2R1bGUgQG5lc3Rqcy1tb2R1bGVzL2lvcmVkaXMgYXBwbGlxdWUgYXV0b21hdGlxdWVtZW50IGxlIHByw6lmaXhlIGNvbmZpZ3Vyw6lcbiAgICogRG9uYyBvbiByZXRvdXJuZSBsYSBjbMOpIHRlbGxlIHF1ZWxsZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRGdWxsS2V5KGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgYXN5bmMgZ2V0PFQ+KGtleTogc3RyaW5nKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmdWxsS2V5ID0gdGhpcy5nZXRGdWxsS2V5KGtleSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMucmVkaXMuZ2V0KGZ1bGxLZXkpO1xuICAgICAgcmV0dXJuIHZhbHVlID8gSlNPTi5wYXJzZSh2YWx1ZSkgOiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDYWNoZSBnZXQgZXJyb3IgZm9yIGtleSAke2tleX06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2V0PFQ+KGtleTogc3RyaW5nLCB2YWx1ZTogVCwgdHRsPzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhY2hlQ29uZmlnID0gZ2V0Q2FjaGVDb25maWcodGhpcy5jb25maWdTZXJ2aWNlKTtcbiAgICAgIGNvbnN0IGZpbmFsVHRsID0gdHRsICE9PSB1bmRlZmluZWQgPyB0dGwgOiBjYWNoZUNvbmZpZy5wZXJmb3JtYW5jZS5kZWZhdWx0VHRsO1xuICAgICAgY29uc3QgZnVsbEtleSA9IHRoaXMuZ2V0RnVsbEtleShrZXkpO1xuICAgICAgXG4gICAgICBhd2FpdCB0aGlzLnJlZGlzLnNldGV4KGZ1bGxLZXksIGZpbmFsVHRsLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDYWNoZSBzZXQgZXJyb3IgZm9yIGtleSAke2tleX06YCwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlbChrZXk6IHN0cmluZyB8IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgaWYgKGtleS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZnVsbEtleXMgPSBrZXkubWFwKGsgPT4gdGhpcy5nZXRGdWxsS2V5KGspKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlZGlzLmRlbCguLi5mdWxsS2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZ1bGxLZXkgPSB0aGlzLmdldEZ1bGxLZXkoa2V5KTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWRpcy5kZWwoZnVsbEtleSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYENhY2hlIGRlbGV0ZSBlcnJvcjpgLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaW52YWxpZGF0ZVByb2plY3RDYWNoZShwcm9qZWN0SWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgQ0FDSEVfS0VZUy5QUk9KRUNUKHByb2plY3RJZCksXG4gICAgICAgIENBQ0hFX0tFWVMuUFJPSkVDVF9TVEFUSVNUSUNTKHByb2plY3RJZCksXG4gICAgICAgIENBQ0hFX0tFWVMuVVNFUl9QUk9KRUNUU19DT1VOVCh1c2VySWQpLFxuICAgICAgXTtcbiAgICAgIFxuICAgICAgLy8gSW52YWxpZGVyIGF1c3NpIGxlcyBsaXN0ZXMgZGUgcHJvamV0cyBkZSBsJ3V0aWxpc2F0ZXVyXG4gICAgICAvLyBQb3VyIGtleXMoKSwgbm91cyBkZXZvbnMgaW5jbHVyZSBsZSBwcsOpZml4ZSBtYW51ZWxsZW1lbnRcbiAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuZ2V0S2V5UHJlZml4KCk7XG4gICAgICBjb25zdCBsaXN0UGF0dGVybiA9IGAke3ByZWZpeH1wcm9qZWN0czoke3VzZXJJZH06KmA7XG4gICAgICBcbiAgICAgIGNvbnN0IGxpc3RLZXlzID0gYXdhaXQgdGhpcy5yZWRpcy5rZXlzKGxpc3RQYXR0ZXJuKTtcbiAgICAgIFxuICAgICAgLy8gRW5sZXZlciBsZSBwcsOpZml4ZSBkZXMgY2zDqXMgdHJvdXbDqWVzIGNhciBkZWwoKSBhcHBsaXF1ZSBhdXRvbWF0aXF1ZW1lbnQgbGUgcHLDqWZpeGVcbiAgICAgIGNvbnN0IGxpc3RLZXlzV2l0aG91dFByZWZpeCA9IGxpc3RLZXlzLm1hcChrZXkgPT4ga2V5LnJlcGxhY2UocHJlZml4LCAnJykpO1xuICAgICAgXG4gICAgICBjb25zdCBhbGxLZXlzVG9EZWxldGUgPSBbLi4ua2V5cywgLi4ubGlzdEtleXNXaXRob3V0UHJlZml4XTtcbiAgICAgIFxuICAgICAgYXdhaXQgdGhpcy5kZWwoYWxsS2V5c1RvRGVsZXRlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgQ2FjaGUgZGVsZXRlIGVycm9yOmAsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBpbnZhbGlkYXRlVXNlclByb2plY3RzQ2FjaGUodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gUmVjaGVyY2hlciB0b3V0ZXMgbGVzIGNsw6lzIGRlIGxpc3RlIHBvdXIgY2V0IHV0aWxpc2F0ZXVyXG4gICAgICAvLyBQb3VyIGtleXMoKSwgbm91cyBkZXZvbnMgaW5jbHVyZSBsZSBwcsOpZml4ZSBtYW51ZWxsZW1lbnRcbiAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuZ2V0S2V5UHJlZml4KCk7XG4gICAgICBjb25zdCBsaXN0UGF0dGVybiA9IGAke3ByZWZpeH1wcm9qZWN0czoke3VzZXJJZH06KmA7XG4gICAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5yZWRpcy5rZXlzKGxpc3RQYXR0ZXJuKTtcbiAgICAgIFxuICAgICAgLy8gRW5sZXZlciBsZSBwcsOpZml4ZSBkZXMgY2zDqXMgdHJvdXbDqWVzIGNhciBkZWwoKSBhcHBsaXF1ZSBhdXRvbWF0aXF1ZW1lbnQgbGUgcHLDqWZpeGVcbiAgICAgIGNvbnN0IGtleXNXaXRob3V0UHJlZml4ID0ga2V5cy5tYXAoa2V5ID0+IGtleS5yZXBsYWNlKHByZWZpeCwgJycpKTtcbiAgICAgIFxuICAgICAgaWYgKGtleXNXaXRob3V0UHJlZml4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWwoa2V5c1dpdGhvdXRQcmVmaXgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDYWNoZSBkZWxldGUgZXJyb3I6YCwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0aG9kZXMgdXRpbGl0YWlyZXMgcG91ciBjb25zdHJ1aXJlIGxlcyBjbMOpcyBkZSBjYWNoZVxuICAgKi9cbiAgZ2V0UHJvamVjdEtleShwcm9qZWN0SWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIENBQ0hFX0tFWVMuUFJPSkVDVChwcm9qZWN0SWQpO1xuICB9XG5cbiAgZ2V0UHJvamVjdExpc3RLZXkodXNlcklkOiBzdHJpbmcsIHBhZ2U6IG51bWJlciwgbGltaXQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIENBQ0hFX0tFWVMuUFJPSkVDVF9MSVNUKHVzZXJJZCwgcGFnZSwgbGltaXQpO1xuICB9XG5cbiAgZ2V0UHJvamVjdFN0YXRpc3RpY3NLZXkocHJvamVjdElkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBDQUNIRV9LRVlTLlBST0pFQ1RfU1RBVElTVElDUyhwcm9qZWN0SWQpO1xuICB9XG5cbiAgZ2V0VXNlclByb2plY3RzQ291bnRLZXkodXNlcklkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBDQUNIRV9LRVlTLlVTRVJfUFJPSkVDVFNfQ09VTlQodXNlcklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSw6ljdXDDqHJlIGxlIHByw6lmaXhlIGRlcyBjbMOpcyBkZXB1aXMgbGEgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0S2V5UHJlZml4KCk6IHN0cmluZyB7XG4gICAgY29uc3QgY2FjaGVDb25maWcgPSBnZXRDYWNoZUNvbmZpZyh0aGlzLmNvbmZpZ1NlcnZpY2UpO1xuICAgIHJldHVybiBjYWNoZUNvbmZpZy5zZXJpYWxpemF0aW9uLmtleVByZWZpeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWw6lyaWZpZSBzaSBSZWRpcyBlc3QgY29ubmVjdMOpXG4gICAqL1xuICBhc3luYyBpc0Nvbm5lY3RlZCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWRpcy5waW5nKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSAnUE9ORyc7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlZGlzIGNvbm5lY3Rpb24gY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUsOpY3Vww6hyZSBkZXMgaW5mb3JtYXRpb25zIHN1ciBSZWRpc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbygpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWRpcy5pbmZvKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlZGlzIGluZm8gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmVybWUgbGEgY29ubmV4aW9uIFJlZGlzICh1dGlsZSBwb3VyIGxlcyB0ZXN0cylcbiAgICovXG4gIGFzeW5jIGRpc2Nvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucmVkaXMucXVpdCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbG9zaW5nIFJlZGlzIGNvbm5lY3Rpb246JywgZXJyb3IpO1xuICAgIH1cbiAgfVxufSJdLCJ2ZXJzaW9uIjozfQ==