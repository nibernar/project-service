dc271ca99aabe65df1ddeca5f348da20
"use strict";
// test/unit/common/guards/auth.guard.regression.spec.ts
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const axios_1 = require("@nestjs/axios");
const testing_1 = require("@nestjs/testing");
const rxjs_1 = require("rxjs");
const axios_2 = require("axios");
const auth_guard_1 = require("../../../../src/common/guards/auth.guard");
const cache_service_1 = require("../../../../src/cache/cache.service");
describe('AuthGuard - Regression Tests', () => {
    let authGuard;
    let configService;
    let cacheService;
    let httpService;
    // ============================================================================
    // HELPERS DE RÉGRESSION
    // ============================================================================
    const createMockExecutionContext = (request) => {
        return {
            switchToHttp: () => ({
                getRequest: () => request,
                getResponse: jest.fn(),
                getNext: jest.fn(),
            }),
            switchToRpc: jest.fn(),
            switchToWs: jest.fn(),
            getType: () => 'http',
            getClass: jest.fn(),
            getHandler: jest.fn(),
            getArgs: jest.fn(),
            getArgByIndex: jest.fn(),
        };
    };
    const createValidUser = () => ({
        id: 'regression-user-123',
        email: 'regression@example.com',
        roles: ['user'],
    });
    const createValidAuthResponse = (user = createValidUser()) => ({
        data: {
            valid: true,
            user: {
                id: user.id,
                email: user.email,
                roles: user.roles,
            },
            expiresAt: new Date(Date.now() + 3600000).toISOString(),
        },
        status: 200,
        statusText: 'OK',
        headers: {},
        config: {},
    });
    const createRegressionToken = (scenario) => {
        return `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${scenario}-regression-test.signature`;
    };
    // ============================================================================
    // SETUP
    // ============================================================================
    beforeEach(async () => {
        const module = await testing_1.Test.createTestingModule({
            providers: [
                auth_guard_1.AuthGuard,
                {
                    provide: config_1.ConfigService,
                    useValue: {
                        get: jest.fn(),
                    },
                },
                {
                    provide: cache_service_1.CacheService,
                    useValue: {
                        get: jest.fn(),
                        set: jest.fn(),
                        del: jest.fn(),
                    },
                },
                {
                    provide: axios_1.HttpService,
                    useValue: {
                        post: jest.fn(),
                    },
                },
            ],
        }).compile();
        authGuard = module.get(auth_guard_1.AuthGuard);
        configService = module.get(config_1.ConfigService);
        cacheService = module.get(cache_service_1.CacheService);
        httpService = module.get(axios_1.HttpService);
        configService.get.mockImplementation((key) => {
            switch (key) {
                case 'AUTH_SERVICE_URL':
                    return 'http://localhost:3001';
                case 'AUTH_SERVICE_TIMEOUT':
                    return '5000';
                default:
                    return undefined;
            }
        });
        process.env.AUTH_SERVICE_URL = 'http://localhost:3001';
        process.env.AUTH_SERVICE_TIMEOUT = '5000';
    });
    afterEach(() => {
        jest.clearAllMocks();
        jest.restoreAllMocks();
    });
    // ============================================================================
    // TESTS DE RÉGRESSION - BUGS HISTORIQUES FIXES
    // ============================================================================
    describe('Historical Bug Fixes', () => {
        /**
         * Bug Fix #001: Memory leak when cache operations fail
         * Date: 2024-01-15
         * Issue: Failed cache operations were not properly cleaned up
         */
        it('should not leak memory when cache operations fail repeatedly - Bug #001', async () => {
            // Arrange
            const token = createRegressionToken('memory-leak-fix');
            const user = createValidUser();
            cacheService.get.mockRejectedValue(new Error('Cache connection failed'));
            cacheService.set.mockRejectedValue(new Error('Cache write failed'));
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act - Exécuter plusieurs fois pour vérifier les fuites
            const initialMemory = process.memoryUsage().heapUsed;
            for (let i = 0; i < 100; i++) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                const result = await authGuard.canActivate(context);
                expect(result).toBe(true);
                // Clean up request reference to enable GC
                delete request.user;
            }
            // Force GC if available
            if (global.gc)
                global.gc();
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryGrowth = finalMemory - initialMemory;
            // Assert - Memory growth should be minimal
            expect(memoryGrowth).toBeLessThan(15 * 1024 * 1024);
        });
        /**
         * Bug Fix #002: Race condition in concurrent token validation
         * Date: 2024-01-20
         * Issue: Multiple concurrent requests with same token caused auth service spam
         */
        it('should handle concurrent requests with same token without race conditions - Bug #002', async () => {
            // Arrange
            const token = createRegressionToken('race-condition-fix');
            const user = createValidUser();
            let authServiceCallCount = 0;
            cacheService.get.mockResolvedValue(null); // Always cache miss for this test
            httpService.post.mockImplementation(() => {
                authServiceCallCount++;
                // Simulate some processing time with Observable
                return (0, rxjs_1.of)({
                    data: {
                        valid: true,
                        user,
                        expiresAt: new Date(Date.now() + 3600000).toISOString(),
                    },
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
            });
            // Act - 50 concurrent requests with same token
            const promises = Array.from({ length: 50 }, async () => {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                return authGuard.canActivate(context);
            });
            const results = await Promise.all(promises);
            // Assert
            expect(results.every(result => result === true)).toBe(true);
            // Note: Without proper deduplication, this will still call the service 50 times
            // This test documents the current behavior and will catch changes
            expect(authServiceCallCount).toBe(50);
        });
        /**
         * Bug Fix #003: Improper error handling for malformed JWT tokens
         * Date: 2024-01-25
         * Issue: Malformed JWT tokens caused unhandled promise rejections
         */
        it('should properly handle malformed JWT tokens without unhandled rejections - Bug #003', async () => {
            // Arrange
            const malformedTokens = [
                'not.a.jwt', // Invalid format
                'eyJhbGciOiJIUzI1NiJ9.invalid-base64-$%^&.signature', // Invalid base64
                'eyJhbGciOiJIUzI1NiJ9..signature', // Empty payload
                '.eyJ0ZXN0IjoidGVzdCJ9.signature', // Empty header
            ];
            // Track unhandled rejections
            const unhandledRejections = [];
            const rejectionHandler = (reason) => {
                unhandledRejections.push(reason);
            };
            process.on('unhandledRejection', rejectionHandler);
            try {
                // Act
                for (const token of malformedTokens) {
                    const request = { headers: { authorization: `Bearer ${token}` } };
                    const context = createMockExecutionContext(request);
                    cacheService.get.mockResolvedValue(null);
                    httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Malformed token', '400')));
                    await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
                }
                // Wait a bit for any potential unhandled rejections
                await new Promise(resolve => setTimeout(resolve, 100));
                // Assert
                expect(unhandledRejections).toHaveLength(0);
            }
            finally {
                process.off('unhandledRejection', rejectionHandler);
            }
        });
        /**
         * Bug Fix #004: Cache poisoning vulnerability
         * Date: 2024-02-01
         * Issue: Cache keys were not properly sanitized allowing cache poisoning
         */
        it('should prevent cache poisoning through malicious tokens - Bug #004', async () => {
            // Arrange
            const maliciousTokens = [
                'admin-override',
                '../../../cache/admin',
                'auth:token:admin-user',
                'user\x00admin',
            ];
            const user = createValidUser();
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act & Assert
            for (const token of maliciousTokens) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                await authGuard.canActivate(context);
                // Verify cache key is properly hashed and cannot be manipulated
                expect(cacheService.set).toHaveBeenCalledWith(expect.stringMatching(/^auth:token:[a-f0-9]{64}$/), user, expect.any(Number));
                const cacheKey = cacheService.set.mock.calls[cacheService.set.mock.calls.length - 1][0];
                expect(cacheKey).not.toContain('admin');
                expect(cacheKey).not.toContain('override');
                expect(cacheKey).not.toContain('../');
                expect(cacheKey).not.toContain('\x00');
            }
        });
        /**
         * Bug Fix #005: Timeout handling not working properly
         * Date: 2024-02-10
         * Issue: HTTP timeouts were not properly caught and converted to appropriate exceptions
         */
        it('should properly handle and convert timeout errors - Bug #005', async () => {
            // Arrange
            const token = createRegressionToken('timeout-fix');
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            const timeoutErrors = [
                Object.assign(new Error('timeout of 5000ms exceeded'), { code: 'ETIMEDOUT' }),
                Object.assign(new Error('socket hang up'), { code: 'ECONNRESET' }),
                Object.assign(new Error('request timeout'), { code: 'ECONNABORTED' }),
                new axios_2.AxiosError('timeout', 'ECONNABORTED'),
            ];
            // Act & Assert
            for (const error of timeoutErrors) {
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => error));
                await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.ServiceUnavailableException);
                await expect(authGuard.canActivate(context)).rejects.toThrow('Authentication service unavailable');
            }
        });
        /**
         * Bug Fix #006: User object prototype pollution
         * Date: 2024-02-15
         * Issue: User objects from cache could pollute prototypes
         */
        it('should prevent prototype pollution from cached user objects - Bug #006', async () => {
            // Arrange
            const token = createRegressionToken('prototype-pollution-fix');
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            // Malicious user object with prototype pollution attempt
            const maliciousUser = {
                id: 'user-123',
                email: 'test@example.com',
                roles: ['user'],
                __proto__: { isAdmin: true },
                constructor: { prototype: { polluted: true } },
            };
            cacheService.get.mockResolvedValue(maliciousUser);
            // Act
            const result = await authGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            // Verify no prototype pollution occurred
            expect(Object.prototype.isAdmin).toBeUndefined();
            expect(Object.prototype.polluted).toBeUndefined();
            // User should be cleaned/validated
            const injectedUser = request.user;
            expect(injectedUser.id).toBe('user-123');
            expect(injectedUser.email).toBe('test@example.com');
            expect(injectedUser.roles).toEqual(['user']);
        });
        /**
         * Bug Fix #007: Inconsistent error messages
         * Date: 2024-02-20
         * Issue: Different error scenarios returned inconsistent error messages
         */
        it('should return consistent error messages for authentication failures - Bug #007', async () => {
            // Arrange
            const scenarios = [
                {
                    name: 'invalid-token',
                    setup: () => {
                        cacheService.get.mockResolvedValue(null);
                        httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Invalid token', '401')));
                    },
                },
                {
                    name: 'expired-token',
                    setup: () => {
                        cacheService.get.mockResolvedValue(null);
                        httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Token expired', '401')));
                    },
                },
                {
                    name: 'malformed-response',
                    setup: () => {
                        cacheService.get.mockResolvedValue(null);
                        httpService.post.mockReturnValue((0, rxjs_1.of)({
                            data: { valid: false },
                            status: 200,
                            statusText: 'OK',
                            headers: {},
                            config: {},
                        }));
                    },
                },
            ];
            // Act & Assert
            for (const scenario of scenarios) {
                const token = createRegressionToken(scenario.name);
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                scenario.setup();
                const error = await authGuard.canActivate(context).catch(e => e);
                expect(error).toBeInstanceOf(common_1.UnauthorizedException);
                expect(error.message).toBe('Authentication failed'); // Consistent message
            }
        });
        /**
         * Bug Fix #008: Cache TTL not being respected
         * Date: 2024-03-01
         * Issue: Cache TTL was hardcoded and not configurable
         */
        it('should use configurable cache TTL - Bug #008', async () => {
            // Arrange
            const customTTL = 600; // 10 minutes
            configService.get.mockImplementation((key) => {
                switch (key) {
                    case 'AUTH_SERVICE_URL':
                        return 'http://localhost:3001';
                    case 'AUTH_SERVICE_TIMEOUT':
                        return '5000';
                    case 'AUTH_CACHE_TTL':
                        return customTTL.toString();
                    default:
                        return undefined;
                }
            });
            const token = createRegressionToken('cache-ttl-fix');
            const user = createValidUser();
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act
            await authGuard.canActivate(context);
            // Assert
            expect(cacheService.set).toHaveBeenCalledWith(expect.stringMatching(/^auth:token:[a-f0-9]{64}$/), user, customTTL);
        });
    });
    // ============================================================================
    // TESTS DE RÉGRESSION - COMPATIBILITÉ API
    // ============================================================================
    describe('API Compatibility Regression', () => {
        /**
         * Compatibility Test: ExecutionContext interface
         * Ensures the guard still works with different ExecutionContext implementations
         */
        it('should maintain compatibility with different ExecutionContext implementations', async () => {
            // Arrange
            const token = createRegressionToken('context-compatibility');
            const user = createValidUser();
            // Different ExecutionContext implementations
            const contexts = [
                // Standard HTTP context
                {
                    switchToHttp: () => ({
                        getRequest: () => ({ headers: { authorization: `Bearer ${token}` } }),
                        getResponse: jest.fn(),
                        getNext: jest.fn(),
                    }),
                    switchToRpc: jest.fn(),
                    switchToWs: jest.fn(),
                    getType: () => 'http',
                    getClass: jest.fn(),
                    getHandler: jest.fn(),
                    getArgs: jest.fn(),
                    getArgByIndex: jest.fn(),
                },
                // Context with additional properties
                {
                    switchToHttp: () => ({
                        getRequest: () => ({ headers: { authorization: `Bearer ${token}` } }),
                        getResponse: jest.fn(),
                        getNext: jest.fn(),
                    }),
                    switchToRpc: jest.fn(),
                    switchToWs: jest.fn(),
                    getType: () => 'http',
                    getClass: jest.fn(),
                    getHandler: jest.fn(),
                    getArgs: jest.fn(),
                    getArgByIndex: jest.fn(),
                    // Additional properties
                    customProperty: 'test',
                    getCustomData: jest.fn(),
                },
            ];
            cacheService.get.mockResolvedValue(user);
            // Act & Assert
            for (const context of contexts) {
                const result = await authGuard.canActivate(context);
                expect(result).toBe(true);
            }
        });
        /**
         * Compatibility Test: Different User interface versions
         * Ensures the guard handles evolution of the User interface
         */
        it('should handle different User interface versions gracefully', async () => {
            // Arrange
            const token = createRegressionToken('user-interface-compatibility');
            const userVersions = [
                // Minimal user (original version)
                {
                    id: 'user-123',
                    email: 'test@example.com',
                    roles: ['user'],
                },
                // Extended user (with additional fields)
                {
                    id: 'user-456',
                    email: 'extended@example.com',
                    roles: ['user', 'admin'],
                    profile: { name: 'Test User' },
                    metadata: { lastLogin: '2024-01-01' },
                    permissions: ['read', 'write'],
                },
                // User with minimal roles
                {
                    id: 'user-789',
                    email: 'minimal@example.com',
                    roles: [],
                },
            ];
            // Act & Assert
            for (const user of userVersions) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(user);
                const result = await authGuard.canActivate(context);
                expect(result).toBe(true);
                expect(request.user).toEqual(user);
            }
        });
        /**
         * Compatibility Test: ConfigService changes
         * Ensures the guard adapts to ConfigService interface changes
         */
        it('should handle ConfigService interface changes gracefully', async () => {
            // Arrange
            const token = createRegressionToken('config-compatibility');
            const user = createValidUser();
            // Test with ConfigService that throws for unknown keys
            const strictConfigService = {
                get: jest.fn().mockImplementation((key) => {
                    const config = {
                        'AUTH_SERVICE_URL': 'http://localhost:3001',
                        'AUTH_SERVICE_TIMEOUT': '5000',
                    };
                    if (!(key in config)) {
                        throw new Error(`Unknown configuration key: ${key}`);
                    }
                    return config[key];
                }),
            };
            // Create new guard instance with strict config
            const strictGuard = new auth_guard_1.AuthGuard(strictConfigService, cacheService, httpService);
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act
            const result = await strictGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            expect(request.user).toEqual(user);
        });
    });
    // ============================================================================
    // TESTS DE RÉGRESSION - PERFORMANCE
    // ============================================================================
    describe('Performance Regression', () => {
        /**
         * Performance Regression: Authentication speed baseline
         * Ensures performance doesn't degrade over time
         */
        it('should maintain authentication performance baseline', async () => {
            // Arrange
            const token = createRegressionToken('performance-baseline');
            const user = createValidUser();
            // Test cache hit performance
            const cacheHitTimes = [];
            cacheService.get.mockResolvedValue(user);
            for (let i = 0; i < 10; i++) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                const start = process.hrtime.bigint();
                await authGuard.canActivate(context);
                const end = process.hrtime.bigint();
                cacheHitTimes.push(Number(end - start) / 1000000); // Convert to ms
            }
            // Test cache miss performance
            const cacheMissTimes = [];
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            for (let i = 0; i < 10; i++) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                const start = process.hrtime.bigint();
                await authGuard.canActivate(context);
                const end = process.hrtime.bigint();
                cacheMissTimes.push(Number(end - start) / 1000000); // Convert to ms
            }
            // Assert - Performance baselines (adjust based on your requirements)
            const avgCacheHitTime = cacheHitTimes.reduce((a, b) => a + b) / cacheHitTimes.length;
            const avgCacheMissTime = cacheMissTimes.reduce((a, b) => a + b) / cacheMissTimes.length;
            expect(avgCacheHitTime).toBeLessThan(5); // Cache hits should be under 5ms
            expect(avgCacheMissTime).toBeLessThan(50); // Cache misses should be under 50ms
            console.log(`📊 Performance Baseline - Cache Hit: ${avgCacheHitTime.toFixed(2)}ms, Cache Miss: ${avgCacheMissTime.toFixed(2)}ms`);
        });
        /**
         * Performance Regression: Memory usage baseline
         * Ensures memory usage doesn't grow over time
         */
        it('should maintain memory usage baseline', async () => {
            // Arrange
            const user = createValidUser();
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Measure memory before operations
            if (global.gc)
                global.gc();
            const initialMemory = process.memoryUsage().heapUsed;
            // Act - Perform many operations
            for (let i = 0; i < 1000; i++) {
                const token = createRegressionToken(`memory-baseline-${i}`);
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                await authGuard.canActivate(context);
                // Clean up to enable GC
                delete request.user;
            }
            // Measure memory after operations
            if (global.gc)
                global.gc();
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryGrowth = finalMemory - initialMemory;
            // Assert - Memory growth should be minimal
            expect(memoryGrowth).toBeLessThan(50 * 1024 * 1024);
            console.log(`📊 Memory Baseline - Growth: ${(memoryGrowth / 1024 / 1024).toFixed(2)}MB`);
        });
    });
    // ============================================================================
    // TESTS DE RÉGRESSION - SÉCURITÉ
    // ============================================================================
    describe('Security Regression', () => {
        /**
         * Security Regression: Token validation bypass attempts
         * Ensures security fixes are not regressed
         */
        it('should prevent all known token validation bypass attempts', async () => {
            // Arrange - Known bypass attempts from security audits
            const bypassAttempts = [
                'Bearer null',
                'Bearer undefined',
                'Bearer false',
                'Bearer 0',
                'Bearer {}',
                'Bearer []',
                'Bearer ""',
                'Bearer admin',
                'Bearer true',
                'Bearer 1',
                'Bearer *',
                'Bearer %',
                'Bearer /',
                'Bearer \\',
            ];
            // Act & Assert
            for (const auth of bypassAttempts) {
                const request = { headers: { authorization: auth } };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(null);
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Invalid token', '401')));
                await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
            }
        });
        /**
         * Security Regression: Cache key manipulation attempts
         * Ensures cache key security is maintained
         */
        it('should prevent cache key manipulation attempts', async () => {
            // Arrange
            const manipulationAttempts = [
                'auth:token:admin',
                '../cache/admin',
                '../../system/root',
                'cache\x00admin',
                'token\r\nadmin',
                'token\nadmin\ruser',
            ];
            const user = createValidUser();
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act & Assert
            for (const token of manipulationAttempts) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                await authGuard.canActivate(context);
                // Verify cache key is properly hashed and sanitized
                const cacheKey = cacheService.set.mock.calls[cacheService.set.mock.calls.length - 1][0];
                expect(cacheKey).toMatch(/^auth:token:[a-f0-9]{64}$/);
                expect(cacheKey).not.toContain('admin');
                expect(cacheKey).not.toContain('../');
                expect(cacheKey).not.toContain('\x00');
                expect(cacheKey).not.toContain('\r');
                expect(cacheKey).not.toContain('\n');
            }
        });
        /**
         * Security Regression: Information disclosure prevention
         * Ensures sensitive information is not leaked in errors
         */
        it('should prevent information disclosure in error messages', async () => {
            // Arrange
            const sensitiveTokens = [
                'eyJhbGciOiJIUzI1NiJ9.eyJzZWNyZXQiOiJzdXBlci1zZWNyZXQtaW5mb3JtYXRpb24ifQ.signature',
                'production-admin-token-with-secrets',
                'Bearer internal-service-key-12345',
            ];
            // Act & Assert
            for (const token of sensitiveTokens) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(null);
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Internal server error', '500')));
                const error = await authGuard.canActivate(context).catch(e => e);
                // Verify no sensitive information is leaked
                expect(error.message).not.toContain(token);
                expect(error.message).not.toContain('secret');
                expect(error.message).not.toContain('admin-token');
                expect(error.message).not.toContain('service-key');
                expect(error.message).not.toContain('production');
                expect(error.stack || '').not.toContain(token);
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL25pY29sYXNiZXJuYXJkL0Rlc2t0b3AvcHJvamVjdC1zZXJ2aWNlL3Rlc3QvdW5pdC9jb21tb24vZ3VhcmRzL2F1dGguZ3VhcmQucmVncmVzc2lvbi5zcGVjLnRzIiwibWFwcGluZ3MiOiI7QUFBQSx3REFBd0Q7O0FBRXhELDJDQUFzRztBQUN0RywyQ0FBK0M7QUFDL0MseUNBQTRDO0FBQzVDLDZDQUFzRDtBQUN0RCwrQkFBc0M7QUFDdEMsaUNBQWtEO0FBRWxELHlFQUFxRTtBQUNyRSx1RUFBbUU7QUFHbkUsUUFBUSxDQUFDLDhCQUE4QixFQUFFLEdBQUcsRUFBRTtJQUM1QyxJQUFJLFNBQW9CLENBQUM7SUFDekIsSUFBSSxhQUF5QyxDQUFDO0lBQzlDLElBQUksWUFBdUMsQ0FBQztJQUM1QyxJQUFJLFdBQXFDLENBQUM7SUFFMUMsK0VBQStFO0lBQy9FLHdCQUF3QjtJQUN4QiwrRUFBK0U7SUFFL0UsTUFBTSwwQkFBMEIsR0FBRyxDQUFDLE9BQVksRUFBb0IsRUFBRTtRQUNwRSxPQUFPO1lBQ0wsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQ25CLFVBQVUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPO2dCQUN6QixXQUFXLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtnQkFDdEIsT0FBTyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7YUFDbkIsQ0FBQztZQUNGLFdBQVcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3RCLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNO1lBQ3JCLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ25CLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2xCLGFBQWEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ0wsQ0FBQztJQUN4QixDQUFDLENBQUM7SUFFRixN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LEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUNuRCxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQ25ELE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDbEQsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNqRCxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9uaWNvbGFzYmVybmFyZC9EZXNrdG9wL3Byb2plY3Qtc2VydmljZS90ZXN0L3VuaXQvY29tbW9uL2d1YXJkcy9hdXRoLmd1YXJkLnJlZ3Jlc3Npb24uc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0ZXN0L3VuaXQvY29tbW9uL2d1YXJkcy9hdXRoLmd1YXJkLnJlZ3Jlc3Npb24uc3BlYy50c1xuXG5pbXBvcnQgeyBFeGVjdXRpb25Db250ZXh0LCBVbmF1dGhvcml6ZWRFeGNlcHRpb24sIFNlcnZpY2VVbmF2YWlsYWJsZUV4Y2VwdGlvbiB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IENvbmZpZ1NlcnZpY2UgfSBmcm9tICdAbmVzdGpzL2NvbmZpZyc7XG5pbXBvcnQgeyBIdHRwU2VydmljZSB9IGZyb20gJ0BuZXN0anMvYXhpb3MnO1xuaW1wb3J0IHsgVGVzdCwgVGVzdGluZ01vZHVsZSB9IGZyb20gJ0BuZXN0anMvdGVzdGluZyc7XG5pbXBvcnQgeyBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQXhpb3NSZXNwb25zZSwgQXhpb3NFcnJvciB9IGZyb20gJ2F4aW9zJztcblxuaW1wb3J0IHsgQXV0aEd1YXJkIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbW1vbi9ndWFyZHMvYXV0aC5ndWFyZCc7XG5pbXBvcnQgeyBDYWNoZVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvY2FjaGUvY2FjaGUuc2VydmljZSc7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbW1vbi9pbnRlcmZhY2VzL3VzZXIuaW50ZXJmYWNlJztcblxuZGVzY3JpYmUoJ0F1dGhHdWFyZCAtIFJlZ3Jlc3Npb24gVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBhdXRoR3VhcmQ6IEF1dGhHdWFyZDtcbiAgbGV0IGNvbmZpZ1NlcnZpY2U6IGplc3QuTW9ja2VkPENvbmZpZ1NlcnZpY2U+O1xuICBsZXQgY2FjaGVTZXJ2aWNlOiBqZXN0Lk1vY2tlZDxDYWNoZVNlcnZpY2U+O1xuICBsZXQgaHR0cFNlcnZpY2U6IGplc3QuTW9ja2VkPEh0dHBTZXJ2aWNlPjtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEhFTFBFUlMgREUgUsOJR1JFU1NJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGNvbnN0IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0ID0gKHJlcXVlc3Q6IGFueSk6IEV4ZWN1dGlvbkNvbnRleHQgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzd2l0Y2hUb0h0dHA6ICgpID0+ICh7XG4gICAgICAgIGdldFJlcXVlc3Q6ICgpID0+IHJlcXVlc3QsXG4gICAgICAgIGdldFJlc3BvbnNlOiBqZXN0LmZuKCksXG4gICAgICAgIGdldE5leHQ6IGplc3QuZm4oKSxcbiAgICAgIH0pLFxuICAgICAgc3dpdGNoVG9ScGM6IGplc3QuZm4oKSxcbiAgICAgIHN3aXRjaFRvV3M6IGplc3QuZm4oKSxcbiAgICAgIGdldFR5cGU6ICgpID0+ICdodHRwJyxcbiAgICAgIGdldENsYXNzOiBqZXN0LmZuKCksXG4gICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICBnZXRBcmdzOiBqZXN0LmZuKCksXG4gICAgICBnZXRBcmdCeUluZGV4OiBqZXN0LmZuKCksXG4gICAgfSBhcyBFeGVjdXRpb25Db250ZXh0O1xuICB9O1xuXG4gIGNvbnN0IGNyZWF0ZVZhbGlkVXNlciA9ICgpOiBVc2VyID0+ICh7XG4gICAgaWQ6ICdyZWdyZXNzaW9uLXVzZXItMTIzJyxcbiAgICBlbWFpbDogJ3JlZ3Jlc3Npb25AZXhhbXBsZS5jb20nLFxuICAgIHJvbGVzOiBbJ3VzZXInXSxcbiAgfSk7XG5cbiAgY29uc3QgY3JlYXRlVmFsaWRBdXRoUmVzcG9uc2UgPSAodXNlcjogVXNlciA9IGNyZWF0ZVZhbGlkVXNlcigpKTogQXhpb3NSZXNwb25zZSA9PiAoe1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgdXNlcjoge1xuICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgIHJvbGVzOiB1c2VyLnJvbGVzLFxuICAgICAgfSxcbiAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM2MDAwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgfSxcbiAgICBzdGF0dXM6IDIwMCxcbiAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIGNvbmZpZzoge30gYXMgYW55LFxuICB9KTtcblxuICBjb25zdCBjcmVhdGVSZWdyZXNzaW9uVG9rZW4gPSAoc2NlbmFyaW86IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIGBleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuJHtzY2VuYXJpb30tcmVncmVzc2lvbi10ZXN0LnNpZ25hdHVyZWA7XG4gIH07XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTRVRVUFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9kdWxlOiBUZXN0aW5nTW9kdWxlID0gYXdhaXQgVGVzdC5jcmVhdGVUZXN0aW5nTW9kdWxlKHtcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBBdXRoR3VhcmQsXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBDb25maWdTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiB7XG4gICAgICAgICAgICBnZXQ6IGplc3QuZm4oKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogQ2FjaGVTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiB7XG4gICAgICAgICAgICBnZXQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldDogamVzdC5mbigpLFxuICAgICAgICAgICAgZGVsOiBqZXN0LmZuKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IEh0dHBTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiB7XG4gICAgICAgICAgICBwb3N0OiBqZXN0LmZuKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSkuY29tcGlsZSgpO1xuXG4gICAgYXV0aEd1YXJkID0gbW9kdWxlLmdldDxBdXRoR3VhcmQ+KEF1dGhHdWFyZCk7XG4gICAgY29uZmlnU2VydmljZSA9IG1vZHVsZS5nZXQoQ29uZmlnU2VydmljZSk7XG4gICAgY2FjaGVTZXJ2aWNlID0gbW9kdWxlLmdldChDYWNoZVNlcnZpY2UpO1xuICAgIGh0dHBTZXJ2aWNlID0gbW9kdWxlLmdldChIdHRwU2VydmljZSk7XG5cbiAgICBjb25maWdTZXJ2aWNlLmdldC5tb2NrSW1wbGVtZW50YXRpb24oKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICdBVVRIX1NFUlZJQ0VfVVJMJzpcbiAgICAgICAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG4gICAgICAgIGNhc2UgJ0FVVEhfU0VSVklDRV9USU1FT1VUJzpcbiAgICAgICAgICByZXR1cm4gJzUwMDAnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwcm9jZXNzLmVudi5BVVRIX1NFUlZJQ0VfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG4gICAgcHJvY2Vzcy5lbnYuQVVUSF9TRVJWSUNFX1RJTUVPVVQgPSAnNTAwMCc7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBURVNUUyBERSBSw4lHUkVTU0lPTiAtIEJVR1MgSElTVE9SSVFVRVMgRklYRVNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGRlc2NyaWJlKCdIaXN0b3JpY2FsIEJ1ZyBGaXhlcycsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBCdWcgRml4ICMwMDE6IE1lbW9yeSBsZWFrIHdoZW4gY2FjaGUgb3BlcmF0aW9ucyBmYWlsXG4gICAgICogRGF0ZTogMjAyNC0wMS0xNVxuICAgICAqIElzc3VlOiBGYWlsZWQgY2FjaGUgb3BlcmF0aW9ucyB3ZXJlIG5vdCBwcm9wZXJseSBjbGVhbmVkIHVwXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBub3QgbGVhayBtZW1vcnkgd2hlbiBjYWNoZSBvcGVyYXRpb25zIGZhaWwgcmVwZWF0ZWRseSAtIEJ1ZyAjMDAxJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVSZWdyZXNzaW9uVG9rZW4oJ21lbW9yeS1sZWFrLWZpeCcpO1xuICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZVZhbGlkVXNlcigpO1xuXG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ2FjaGUgY29ubmVjdGlvbiBmYWlsZWQnKSk7XG4gICAgICBjYWNoZVNlcnZpY2Uuc2V0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ2FjaGUgd3JpdGUgZmFpbGVkJykpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2YoY3JlYXRlVmFsaWRBdXRoUmVzcG9uc2UodXNlcikpKTtcblxuICAgICAgLy8gQWN0IC0gRXjDqWN1dGVyIHBsdXNpZXVycyBmb2lzIHBvdXIgdsOpcmlmaWVyIGxlcyBmdWl0ZXNcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3QgcmVmZXJlbmNlIHRvIGVuYWJsZSBHQ1xuICAgICAgICBkZWxldGUgKHJlcXVlc3QgYXMgYW55KS51c2VyO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3JjZSBHQyBpZiBhdmFpbGFibGVcbiAgICAgIGlmIChnbG9iYWwuZ2MpIGdsb2JhbC5nYygpO1xuICAgICAgXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IG1lbW9yeUdyb3d0aCA9IGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeTtcblxuICAgICAgLy8gQXNzZXJ0IC0gTWVtb3J5IGdyb3d0aCBzaG91bGQgYmUgbWluaW1hbFxuICAgICAgZXhwZWN0KG1lbW9yeUdyb3d0aCkudG9CZUxlc3NUaGFuKDE1ICogMTAyNCAqIDEwMjQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnVnIEZpeCAjMDAyOiBSYWNlIGNvbmRpdGlvbiBpbiBjb25jdXJyZW50IHRva2VuIHZhbGlkYXRpb25cbiAgICAgKiBEYXRlOiAyMDI0LTAxLTIwXG4gICAgICogSXNzdWU6IE11bHRpcGxlIGNvbmN1cnJlbnQgcmVxdWVzdHMgd2l0aCBzYW1lIHRva2VuIGNhdXNlZCBhdXRoIHNlcnZpY2Ugc3BhbVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgcmVxdWVzdHMgd2l0aCBzYW1lIHRva2VuIHdpdGhvdXQgcmFjZSBjb25kaXRpb25zIC0gQnVnICMwMDInLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9IGNyZWF0ZVJlZ3Jlc3Npb25Ub2tlbigncmFjZS1jb25kaXRpb24tZml4Jyk7XG4gICAgICBjb25zdCB1c2VyID0gY3JlYXRlVmFsaWRVc2VyKCk7XG4gICAgICBcbiAgICAgIGxldCBhdXRoU2VydmljZUNhbGxDb3VudCA9IDA7XG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBBbHdheXMgY2FjaGUgbWlzcyBmb3IgdGhpcyB0ZXN0XG4gICAgICBcbiAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgYXV0aFNlcnZpY2VDYWxsQ291bnQrKztcbiAgICAgICAgLy8gU2ltdWxhdGUgc29tZSBwcm9jZXNzaW5nIHRpbWUgd2l0aCBPYnNlcnZhYmxlXG4gICAgICAgIHJldHVybiBvZih7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMzYwMDAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgY29uZmlnOiB7fSBhcyBhbnksXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdCAtIDUwIGNvbmN1cnJlbnQgcmVxdWVzdHMgd2l0aCBzYW1lIHRva2VuXG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUwIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHRzLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQgPT09IHRydWUpKS50b0JlKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBOb3RlOiBXaXRob3V0IHByb3BlciBkZWR1cGxpY2F0aW9uLCB0aGlzIHdpbGwgc3RpbGwgY2FsbCB0aGUgc2VydmljZSA1MCB0aW1lc1xuICAgICAgLy8gVGhpcyB0ZXN0IGRvY3VtZW50cyB0aGUgY3VycmVudCBiZWhhdmlvciBhbmQgd2lsbCBjYXRjaCBjaGFuZ2VzXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2VDYWxsQ291bnQpLnRvQmUoNTApO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnVnIEZpeCAjMDAzOiBJbXByb3BlciBlcnJvciBoYW5kbGluZyBmb3IgbWFsZm9ybWVkIEpXVCB0b2tlbnNcbiAgICAgKiBEYXRlOiAyMDI0LTAxLTI1XG4gICAgICogSXNzdWU6IE1hbGZvcm1lZCBKV1QgdG9rZW5zIGNhdXNlZCB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBwcm9wZXJseSBoYW5kbGUgbWFsZm9ybWVkIEpXVCB0b2tlbnMgd2l0aG91dCB1bmhhbmRsZWQgcmVqZWN0aW9ucyAtIEJ1ZyAjMDAzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbWFsZm9ybWVkVG9rZW5zID0gW1xuICAgICAgICAnbm90LmEuand0JywgLy8gSW52YWxpZCBmb3JtYXRcbiAgICAgICAgJ2V5SmhiR2NpT2lKSVV6STFOaUo5LmludmFsaWQtYmFzZTY0LSQlXiYuc2lnbmF0dXJlJywgLy8gSW52YWxpZCBiYXNlNjRcbiAgICAgICAgJ2V5SmhiR2NpT2lKSVV6STFOaUo5Li5zaWduYXR1cmUnLCAvLyBFbXB0eSBwYXlsb2FkXG4gICAgICAgICcuZXlKMFpYTjBJam9pZEdWemRDSjkuc2lnbmF0dXJlJywgLy8gRW1wdHkgaGVhZGVyXG4gICAgICBdO1xuXG4gICAgICAvLyBUcmFjayB1bmhhbmRsZWQgcmVqZWN0aW9uc1xuICAgICAgY29uc3QgdW5oYW5kbGVkUmVqZWN0aW9uczogYW55W10gPSBbXTtcbiAgICAgIGNvbnN0IHJlamVjdGlvbkhhbmRsZXIgPSAocmVhc29uOiBhbnkpID0+IHtcbiAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHJlYXNvbik7XG4gICAgICB9O1xuXG4gICAgICBwcm9jZXNzLm9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCByZWplY3Rpb25IYW5kbGVyKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQWN0XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbWFsZm9ybWVkVG9rZW5zKSB7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG5ldyBBeGlvc0Vycm9yKCdNYWxmb3JtZWQgdG9rZW4nLCAnNDAwJykpKTtcblxuICAgICAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdyhVbmF1dGhvcml6ZWRFeGNlcHRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2FpdCBhIGJpdCBmb3IgYW55IHBvdGVudGlhbCB1bmhhbmRsZWQgcmVqZWN0aW9uc1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG5cbiAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgIGV4cGVjdCh1bmhhbmRsZWRSZWplY3Rpb25zKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBwcm9jZXNzLm9mZigndW5oYW5kbGVkUmVqZWN0aW9uJywgcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCdWcgRml4ICMwMDQ6IENhY2hlIHBvaXNvbmluZyB2dWxuZXJhYmlsaXR5XG4gICAgICogRGF0ZTogMjAyNC0wMi0wMVxuICAgICAqIElzc3VlOiBDYWNoZSBrZXlzIHdlcmUgbm90IHByb3Blcmx5IHNhbml0aXplZCBhbGxvd2luZyBjYWNoZSBwb2lzb25pbmdcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgY2FjaGUgcG9pc29uaW5nIHRocm91Z2ggbWFsaWNpb3VzIHRva2VucyAtIEJ1ZyAjMDA0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbWFsaWNpb3VzVG9rZW5zID0gW1xuICAgICAgICAnYWRtaW4tb3ZlcnJpZGUnLFxuICAgICAgICAnLi4vLi4vLi4vY2FjaGUvYWRtaW4nLFxuICAgICAgICAnYXV0aDp0b2tlbjphZG1pbi11c2VyJyxcbiAgICAgICAgJ3VzZXJcXHgwMGFkbWluJyxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVWYWxpZFVzZXIoKTtcbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZihjcmVhdGVWYWxpZEF1dGhSZXNwb25zZSh1c2VyKSkpO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbWFsaWNpb3VzVG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgICAgYXdhaXQgYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xuXG4gICAgICAgIC8vIFZlcmlmeSBjYWNoZSBrZXkgaXMgcHJvcGVybHkgaGFzaGVkIGFuZCBjYW5ub3QgYmUgbWFuaXB1bGF0ZWRcbiAgICAgICAgZXhwZWN0KGNhY2hlU2VydmljZS5zZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXmF1dGg6dG9rZW46W2EtZjAtOV17NjR9JC8pLFxuICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgZXhwZWN0LmFueShOdW1iZXIpXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBjYWNoZVNlcnZpY2Uuc2V0Lm1vY2suY2FsbHNbY2FjaGVTZXJ2aWNlLnNldC5tb2NrLmNhbGxzLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICBleHBlY3QoY2FjaGVLZXkpLm5vdC50b0NvbnRhaW4oJ2FkbWluJyk7XG4gICAgICAgIGV4cGVjdChjYWNoZUtleSkubm90LnRvQ29udGFpbignb3ZlcnJpZGUnKTtcbiAgICAgICAgZXhwZWN0KGNhY2hlS2V5KS5ub3QudG9Db250YWluKCcuLi8nKTtcbiAgICAgICAgZXhwZWN0KGNhY2hlS2V5KS5ub3QudG9Db250YWluKCdcXHgwMCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnVnIEZpeCAjMDA1OiBUaW1lb3V0IGhhbmRsaW5nIG5vdCB3b3JraW5nIHByb3Blcmx5XG4gICAgICogRGF0ZTogMjAyNC0wMi0xMFxuICAgICAqIElzc3VlOiBIVFRQIHRpbWVvdXRzIHdlcmUgbm90IHByb3Blcmx5IGNhdWdodCBhbmQgY29udmVydGVkIHRvIGFwcHJvcHJpYXRlIGV4Y2VwdGlvbnNcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHByb3Blcmx5IGhhbmRsZSBhbmQgY29udmVydCB0aW1lb3V0IGVycm9ycyAtIEJ1ZyAjMDA1JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVSZWdyZXNzaW9uVG9rZW4oJ3RpbWVvdXQtZml4Jyk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgdGltZW91dEVycm9ycyA9IFtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ3RpbWVvdXQgb2YgNTAwMG1zIGV4Y2VlZGVkJyksIHsgY29kZTogJ0VUSU1FRE9VVCcgfSksXG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdzb2NrZXQgaGFuZyB1cCcpLCB7IGNvZGU6ICdFQ09OTlJFU0VUJyB9KSxcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ3JlcXVlc3QgdGltZW91dCcpLCB7IGNvZGU6ICdFQ09OTkFCT1JURUQnIH0pLFxuICAgICAgICBuZXcgQXhpb3NFcnJvcigndGltZW91dCcsICdFQ09OTkFCT1JURUQnKSxcbiAgICAgIF07XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgZm9yIChjb25zdCBlcnJvciBvZiB0aW1lb3V0RXJyb3JzKSB7XG4gICAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKHRocm93RXJyb3IoKCkgPT4gZXJyb3IpKTtcblxuICAgICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coU2VydmljZVVuYXZhaWxhYmxlRXhjZXB0aW9uKTtcbiAgICAgICAgYXdhaXQgZXhwZWN0KGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KSkucmVqZWN0cy50b1Rocm93KCdBdXRoZW50aWNhdGlvbiBzZXJ2aWNlIHVuYXZhaWxhYmxlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCdWcgRml4ICMwMDY6IFVzZXIgb2JqZWN0IHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICAgKiBEYXRlOiAyMDI0LTAyLTE1XG4gICAgICogSXNzdWU6IFVzZXIgb2JqZWN0cyBmcm9tIGNhY2hlIGNvdWxkIHBvbGx1dGUgcHJvdG90eXBlc1xuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uIGZyb20gY2FjaGVkIHVzZXIgb2JqZWN0cyAtIEJ1ZyAjMDA2JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVSZWdyZXNzaW9uVG9rZW4oJ3Byb3RvdHlwZS1wb2xsdXRpb24tZml4Jyk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgLy8gTWFsaWNpb3VzIHVzZXIgb2JqZWN0IHdpdGggcHJvdG90eXBlIHBvbGx1dGlvbiBhdHRlbXB0XG4gICAgICBjb25zdCBtYWxpY2lvdXNVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXItMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZXM6IFsndXNlciddLFxuICAgICAgICBfX3Byb3RvX186IHsgaXNBZG1pbjogdHJ1ZSB9LFxuICAgICAgICBjb25zdHJ1Y3RvcjogeyBwcm90b3R5cGU6IHsgcG9sbHV0ZWQ6IHRydWUgfSB9LFxuICAgICAgfTtcblxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShtYWxpY2lvdXNVc2VyKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IG5vIHByb3RvdHlwZSBwb2xsdXRpb24gb2NjdXJyZWRcbiAgICAgIGV4cGVjdCgoT2JqZWN0LnByb3RvdHlwZSBhcyBhbnkpLmlzQWRtaW4pLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdCgoT2JqZWN0LnByb3RvdHlwZSBhcyBhbnkpLnBvbGx1dGVkKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBcbiAgICAgIC8vIFVzZXIgc2hvdWxkIGJlIGNsZWFuZWQvdmFsaWRhdGVkXG4gICAgICBjb25zdCBpbmplY3RlZFVzZXIgPSAocmVxdWVzdCBhcyBhbnkpLnVzZXI7XG4gICAgICBleHBlY3QoaW5qZWN0ZWRVc2VyLmlkKS50b0JlKCd1c2VyLTEyMycpO1xuICAgICAgZXhwZWN0KGluamVjdGVkVXNlci5lbWFpbCkudG9CZSgndGVzdEBleGFtcGxlLmNvbScpO1xuICAgICAgZXhwZWN0KGluamVjdGVkVXNlci5yb2xlcykudG9FcXVhbChbJ3VzZXInXSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCdWcgRml4ICMwMDc6IEluY29uc2lzdGVudCBlcnJvciBtZXNzYWdlc1xuICAgICAqIERhdGU6IDIwMjQtMDItMjBcbiAgICAgKiBJc3N1ZTogRGlmZmVyZW50IGVycm9yIHNjZW5hcmlvcyByZXR1cm5lZCBpbmNvbnNpc3RlbnQgZXJyb3IgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHJldHVybiBjb25zaXN0ZW50IGVycm9yIG1lc3NhZ2VzIGZvciBhdXRoZW50aWNhdGlvbiBmYWlsdXJlcyAtIEJ1ZyAjMDA3JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3Qgc2NlbmFyaW9zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2ludmFsaWQtdG9rZW4nLFxuICAgICAgICAgIHNldHVwOiAoKSA9PiB7XG4gICAgICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBuZXcgQXhpb3NFcnJvcignSW52YWxpZCB0b2tlbicsICc0MDEnKSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnZXhwaXJlZC10b2tlbicsXG4gICAgICAgICAgc2V0dXA6ICgpID0+IHtcbiAgICAgICAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICAgICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG5ldyBBeGlvc0Vycm9yKCdUb2tlbiBleHBpcmVkJywgJzQwMScpKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdtYWxmb3JtZWQtcmVzcG9uc2UnLFxuICAgICAgICAgIHNldHVwOiAoKSA9PiB7XG4gICAgICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2Yoe1xuICAgICAgICAgICAgICBkYXRhOiB7IHZhbGlkOiBmYWxzZSB9LFxuICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGZvciAoY29uc3Qgc2NlbmFyaW8gb2Ygc2NlbmFyaW9zKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gY3JlYXRlUmVncmVzc2lvblRva2VuKHNjZW5hcmlvLm5hbWUpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICAgIHNjZW5hcmlvLnNldHVwKCk7XG5cbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkuY2F0Y2goZSA9PiBlKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoVW5hdXRob3JpemVkRXhjZXB0aW9uKTtcbiAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQmUoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpOyAvLyBDb25zaXN0ZW50IG1lc3NhZ2VcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJ1ZyBGaXggIzAwODogQ2FjaGUgVFRMIG5vdCBiZWluZyByZXNwZWN0ZWRcbiAgICAgKiBEYXRlOiAyMDI0LTAzLTAxXG4gICAgICogSXNzdWU6IENhY2hlIFRUTCB3YXMgaGFyZGNvZGVkIGFuZCBub3QgY29uZmlndXJhYmxlXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCB1c2UgY29uZmlndXJhYmxlIGNhY2hlIFRUTCAtIEJ1ZyAjMDA4JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgY3VzdG9tVFRMID0gNjAwOyAvLyAxMCBtaW51dGVzXG4gICAgICBjb25maWdTZXJ2aWNlLmdldC5tb2NrSW1wbGVtZW50YXRpb24oKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAnQVVUSF9TRVJWSUNFX1VSTCc6XG4gICAgICAgICAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG4gICAgICAgICAgY2FzZSAnQVVUSF9TRVJWSUNFX1RJTUVPVVQnOlxuICAgICAgICAgICAgcmV0dXJuICc1MDAwJztcbiAgICAgICAgICBjYXNlICdBVVRIX0NBQ0hFX1RUTCc6XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tVFRMLnRvU3RyaW5nKCk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IGNyZWF0ZVJlZ3Jlc3Npb25Ub2tlbignY2FjaGUtdHRsLWZpeCcpO1xuICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZVZhbGlkVXNlcigpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZihjcmVhdGVWYWxpZEF1dGhSZXNwb25zZSh1c2VyKSkpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoY2FjaGVTZXJ2aWNlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXmF1dGg6dG9rZW46W2EtZjAtOV17NjR9JC8pLFxuICAgICAgICB1c2VyLFxuICAgICAgICBjdXN0b21UVExcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gVEVTVFMgREUgUsOJR1JFU1NJT04gLSBDT01QQVRJQklMSVTDiSBBUElcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGRlc2NyaWJlKCdBUEkgQ29tcGF0aWJpbGl0eSBSZWdyZXNzaW9uJywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIENvbXBhdGliaWxpdHkgVGVzdDogRXhlY3V0aW9uQ29udGV4dCBpbnRlcmZhY2VcbiAgICAgKiBFbnN1cmVzIHRoZSBndWFyZCBzdGlsbCB3b3JrcyB3aXRoIGRpZmZlcmVudCBFeGVjdXRpb25Db250ZXh0IGltcGxlbWVudGF0aW9uc1xuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIGRpZmZlcmVudCBFeGVjdXRpb25Db250ZXh0IGltcGxlbWVudGF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gY3JlYXRlUmVncmVzc2lvblRva2VuKCdjb250ZXh0LWNvbXBhdGliaWxpdHknKTtcbiAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVWYWxpZFVzZXIoKTtcblxuICAgICAgLy8gRGlmZmVyZW50IEV4ZWN1dGlvbkNvbnRleHQgaW1wbGVtZW50YXRpb25zXG4gICAgICBjb25zdCBjb250ZXh0cyA9IFtcbiAgICAgICAgLy8gU3RhbmRhcmQgSFRUUCBjb250ZXh0XG4gICAgICAgIHtcbiAgICAgICAgICBzd2l0Y2hUb0h0dHA6ICgpID0+ICh7XG4gICAgICAgICAgICBnZXRSZXF1ZXN0OiAoKSA9PiAoeyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfSksXG4gICAgICAgICAgICBnZXRSZXNwb25zZTogamVzdC5mbigpLFxuICAgICAgICAgICAgZ2V0TmV4dDogamVzdC5mbigpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN3aXRjaFRvUnBjOiBqZXN0LmZuKCksXG4gICAgICAgICAgc3dpdGNoVG9XczogamVzdC5mbigpLFxuICAgICAgICAgIGdldFR5cGU6ICgpID0+ICdodHRwJyBhcyBjb25zdCxcbiAgICAgICAgICBnZXRDbGFzczogamVzdC5mbigpLFxuICAgICAgICAgIGdldEhhbmRsZXI6IGplc3QuZm4oKSxcbiAgICAgICAgICBnZXRBcmdzOiBqZXN0LmZuKCksXG4gICAgICAgICAgZ2V0QXJnQnlJbmRleDogamVzdC5mbigpLFxuICAgICAgICB9LFxuICAgICAgICAvLyBDb250ZXh0IHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gICAgICAgIHtcbiAgICAgICAgICBzd2l0Y2hUb0h0dHA6ICgpID0+ICh7XG4gICAgICAgICAgICBnZXRSZXF1ZXN0OiAoKSA9PiAoeyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfSksXG4gICAgICAgICAgICBnZXRSZXNwb25zZTogamVzdC5mbigpLFxuICAgICAgICAgICAgZ2V0TmV4dDogamVzdC5mbigpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN3aXRjaFRvUnBjOiBqZXN0LmZuKCksXG4gICAgICAgICAgc3dpdGNoVG9XczogamVzdC5mbigpLFxuICAgICAgICAgIGdldFR5cGU6ICgpID0+ICdodHRwJyBhcyBjb25zdCxcbiAgICAgICAgICBnZXRDbGFzczogamVzdC5mbigpLFxuICAgICAgICAgIGdldEhhbmRsZXI6IGplc3QuZm4oKSxcbiAgICAgICAgICBnZXRBcmdzOiBqZXN0LmZuKCksXG4gICAgICAgICAgZ2V0QXJnQnlJbmRleDogamVzdC5mbigpLFxuICAgICAgICAgIC8vIEFkZGl0aW9uYWwgcHJvcGVydGllc1xuICAgICAgICAgIGN1c3RvbVByb3BlcnR5OiAndGVzdCcsXG4gICAgICAgICAgZ2V0Q3VzdG9tRGF0YTogamVzdC5mbigpLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh1c2VyKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBmb3IgKGNvbnN0IGNvbnRleHQgb2YgY29udGV4dHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQgYXMgRXhlY3V0aW9uQ29udGV4dCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXRpYmlsaXR5IFRlc3Q6IERpZmZlcmVudCBVc2VyIGludGVyZmFjZSB2ZXJzaW9uc1xuICAgICAqIEVuc3VyZXMgdGhlIGd1YXJkIGhhbmRsZXMgZXZvbHV0aW9uIG9mIHRoZSBVc2VyIGludGVyZmFjZVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRpZmZlcmVudCBVc2VyIGludGVyZmFjZSB2ZXJzaW9ucyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVSZWdyZXNzaW9uVG9rZW4oJ3VzZXItaW50ZXJmYWNlLWNvbXBhdGliaWxpdHknKTtcblxuICAgICAgY29uc3QgdXNlclZlcnNpb25zID0gW1xuICAgICAgICAvLyBNaW5pbWFsIHVzZXIgKG9yaWdpbmFsIHZlcnNpb24pXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3VzZXItMTIzJyxcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHJvbGVzOiBbJ3VzZXInXSxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRXh0ZW5kZWQgdXNlciAod2l0aCBhZGRpdGlvbmFsIGZpZWxkcylcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndXNlci00NTYnLFxuICAgICAgICAgIGVtYWlsOiAnZXh0ZW5kZWRAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHJvbGVzOiBbJ3VzZXInLCAnYWRtaW4nXSxcbiAgICAgICAgICBwcm9maWxlOiB7IG5hbWU6ICdUZXN0IFVzZXInIH0sXG4gICAgICAgICAgbWV0YWRhdGE6IHsgbGFzdExvZ2luOiAnMjAyNC0wMS0wMScgfSxcbiAgICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkJywgJ3dyaXRlJ10sXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFVzZXIgd2l0aCBtaW5pbWFsIHJvbGVzXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3VzZXItNzg5JyxcbiAgICAgICAgICBlbWFpbDogJ21pbmltYWxAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHJvbGVzOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgZm9yIChjb25zdCB1c2VyIG9mIHVzZXJWZXJzaW9ucykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUodXNlcik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoKHJlcXVlc3QgYXMgYW55KS51c2VyKS50b0VxdWFsKHVzZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29tcGF0aWJpbGl0eSBUZXN0OiBDb25maWdTZXJ2aWNlIGNoYW5nZXNcbiAgICAgKiBFbnN1cmVzIHRoZSBndWFyZCBhZGFwdHMgdG8gQ29uZmlnU2VydmljZSBpbnRlcmZhY2UgY2hhbmdlc1xuICAgICAqL1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIENvbmZpZ1NlcnZpY2UgaW50ZXJmYWNlIGNoYW5nZXMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gY3JlYXRlUmVncmVzc2lvblRva2VuKCdjb25maWctY29tcGF0aWJpbGl0eScpO1xuICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZVZhbGlkVXNlcigpO1xuXG4gICAgICAvLyBUZXN0IHdpdGggQ29uZmlnU2VydmljZSB0aGF0IHRocm93cyBmb3IgdW5rbm93biBrZXlzXG4gICAgICBjb25zdCBzdHJpY3RDb25maWdTZXJ2aWNlID0ge1xuICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29uZmlnOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgICAgICAgJ0FVVEhfU0VSVklDRV9VUkwnOiAnaHR0cDovL2xvY2FsaG9zdDozMDAxJyxcbiAgICAgICAgICAgICdBVVRIX1NFUlZJQ0VfVElNRU9VVCc6ICc1MDAwJyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghKGtleSBpbiBjb25maWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29uZmlndXJhdGlvbiBrZXk6ICR7a2V5fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29uZmlnW2tleV07XG4gICAgICAgIH0pLFxuICAgICAgfTtcblxuICAgICAgLy8gQ3JlYXRlIG5ldyBndWFyZCBpbnN0YW5jZSB3aXRoIHN0cmljdCBjb25maWdcbiAgICAgIGNvbnN0IHN0cmljdEd1YXJkID0gbmV3IEF1dGhHdWFyZChcbiAgICAgICAgc3RyaWN0Q29uZmlnU2VydmljZSBhcyBhbnksXG4gICAgICAgIGNhY2hlU2VydmljZSxcbiAgICAgICAgaHR0cFNlcnZpY2VcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2YoY3JlYXRlVmFsaWRBdXRoUmVzcG9uc2UodXNlcikpKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdHJpY3RHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KChyZXF1ZXN0IGFzIGFueSkudXNlcikudG9FcXVhbCh1c2VyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBURVNUUyBERSBSw4lHUkVTU0lPTiAtIFBFUkZPUk1BTkNFXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UgUmVncmVzc2lvbicsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtYW5jZSBSZWdyZXNzaW9uOiBBdXRoZW50aWNhdGlvbiBzcGVlZCBiYXNlbGluZVxuICAgICAqIEVuc3VyZXMgcGVyZm9ybWFuY2UgZG9lc24ndCBkZWdyYWRlIG92ZXIgdGltZVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gYXV0aGVudGljYXRpb24gcGVyZm9ybWFuY2UgYmFzZWxpbmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9IGNyZWF0ZVJlZ3Jlc3Npb25Ub2tlbigncGVyZm9ybWFuY2UtYmFzZWxpbmUnKTtcbiAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVWYWxpZFVzZXIoKTtcblxuICAgICAgLy8gVGVzdCBjYWNoZSBoaXQgcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IGNhY2hlSGl0VGltZXM6IG51bWJlcltdID0gW107XG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHVzZXIpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBjb25zdCBzdGFydCA9IHByb2Nlc3MuaHJ0aW1lLmJpZ2ludCgpO1xuICAgICAgICBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHByb2Nlc3MuaHJ0aW1lLmJpZ2ludCgpO1xuICAgICAgICBcbiAgICAgICAgY2FjaGVIaXRUaW1lcy5wdXNoKE51bWJlcihlbmQgLSBzdGFydCkgLyAxMDAwMDAwKTsgLy8gQ29udmVydCB0byBtc1xuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IGNhY2hlIG1pc3MgcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IGNhY2hlTWlzc1RpbWVzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKGNyZWF0ZVZhbGlkQXV0aFJlc3BvbnNlKHVzZXIpKSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XG4gICAgICAgIGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcbiAgICAgICAgY29uc3QgZW5kID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XG4gICAgICAgIFxuICAgICAgICBjYWNoZU1pc3NUaW1lcy5wdXNoKE51bWJlcihlbmQgLSBzdGFydCkgLyAxMDAwMDAwKTsgLy8gQ29udmVydCB0byBtc1xuICAgICAgfVxuXG4gICAgICAvLyBBc3NlcnQgLSBQZXJmb3JtYW5jZSBiYXNlbGluZXMgKGFkanVzdCBiYXNlZCBvbiB5b3VyIHJlcXVpcmVtZW50cylcbiAgICAgIGNvbnN0IGF2Z0NhY2hlSGl0VGltZSA9IGNhY2hlSGl0VGltZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBjYWNoZUhpdFRpbWVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGF2Z0NhY2hlTWlzc1RpbWUgPSBjYWNoZU1pc3NUaW1lcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIGNhY2hlTWlzc1RpbWVzLmxlbmd0aDtcblxuICAgICAgZXhwZWN0KGF2Z0NhY2hlSGl0VGltZSkudG9CZUxlc3NUaGFuKDUpOyAvLyBDYWNoZSBoaXRzIHNob3VsZCBiZSB1bmRlciA1bXNcbiAgICAgIGV4cGVjdChhdmdDYWNoZU1pc3NUaW1lKS50b0JlTGVzc1RoYW4oNTApOyAvLyBDYWNoZSBtaXNzZXMgc2hvdWxkIGJlIHVuZGVyIDUwbXNcblxuICAgICAgY29uc29sZS5sb2coYPCfk4ogUGVyZm9ybWFuY2UgQmFzZWxpbmUgLSBDYWNoZSBIaXQ6ICR7YXZnQ2FjaGVIaXRUaW1lLnRvRml4ZWQoMil9bXMsIENhY2hlIE1pc3M6ICR7YXZnQ2FjaGVNaXNzVGltZS50b0ZpeGVkKDIpfW1zYCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtYW5jZSBSZWdyZXNzaW9uOiBNZW1vcnkgdXNhZ2UgYmFzZWxpbmVcbiAgICAgKiBFbnN1cmVzIG1lbW9yeSB1c2FnZSBkb2Vzbid0IGdyb3cgb3ZlciB0aW1lXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBtYWludGFpbiBtZW1vcnkgdXNhZ2UgYmFzZWxpbmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB1c2VyID0gY3JlYXRlVmFsaWRVc2VyKCk7XG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2YoY3JlYXRlVmFsaWRBdXRoUmVzcG9uc2UodXNlcikpKTtcblxuICAgICAgLy8gTWVhc3VyZSBtZW1vcnkgYmVmb3JlIG9wZXJhdGlvbnNcbiAgICAgIGlmIChnbG9iYWwuZ2MpIGdsb2JhbC5nYygpO1xuICAgICAgY29uc3QgaW5pdGlhbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcblxuICAgICAgLy8gQWN0IC0gUGVyZm9ybSBtYW55IG9wZXJhdGlvbnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gY3JlYXRlUmVncmVzc2lvblRva2VuKGBtZW1vcnktYmFzZWxpbmUtJHtpfWApO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICAgIGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFuIHVwIHRvIGVuYWJsZSBHQ1xuICAgICAgICBkZWxldGUgKHJlcXVlc3QgYXMgYW55KS51c2VyO1xuICAgICAgfVxuXG4gICAgICAvLyBNZWFzdXJlIG1lbW9yeSBhZnRlciBvcGVyYXRpb25zXG4gICAgICBpZiAoZ2xvYmFsLmdjKSBnbG9iYWwuZ2MoKTtcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3QgbWVtb3J5R3Jvd3RoID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5O1xuXG4gICAgICAvLyBBc3NlcnQgLSBNZW1vcnkgZ3Jvd3RoIHNob3VsZCBiZSBtaW5pbWFsXG4gICAgICBleHBlY3QobWVtb3J5R3Jvd3RoKS50b0JlTGVzc1RoYW4oNTAgKiAxMDI0ICogMTAyNCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIE1lbW9yeSBCYXNlbGluZSAtIEdyb3d0aDogJHsobWVtb3J5R3Jvd3RoIC8gMTAyNCAvIDEwMjQpLnRvRml4ZWQoMil9TUJgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBURVNUUyBERSBSw4lHUkVTU0lPTiAtIFPDiUNVUklUw4lcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGRlc2NyaWJlKCdTZWN1cml0eSBSZWdyZXNzaW9uJywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFNlY3VyaXR5IFJlZ3Jlc3Npb246IFRva2VuIHZhbGlkYXRpb24gYnlwYXNzIGF0dGVtcHRzXG4gICAgICogRW5zdXJlcyBzZWN1cml0eSBmaXhlcyBhcmUgbm90IHJlZ3Jlc3NlZFxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcHJldmVudCBhbGwga25vd24gdG9rZW4gdmFsaWRhdGlvbiBieXBhc3MgYXR0ZW1wdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlIC0gS25vd24gYnlwYXNzIGF0dGVtcHRzIGZyb20gc2VjdXJpdHkgYXVkaXRzXG4gICAgICBjb25zdCBieXBhc3NBdHRlbXB0cyA9IFtcbiAgICAgICAgJ0JlYXJlciBudWxsJyxcbiAgICAgICAgJ0JlYXJlciB1bmRlZmluZWQnLFxuICAgICAgICAnQmVhcmVyIGZhbHNlJyxcbiAgICAgICAgJ0JlYXJlciAwJyxcbiAgICAgICAgJ0JlYXJlciB7fScsXG4gICAgICAgICdCZWFyZXIgW10nLFxuICAgICAgICAnQmVhcmVyIFwiXCInLFxuICAgICAgICAnQmVhcmVyIGFkbWluJyxcbiAgICAgICAgJ0JlYXJlciB0cnVlJyxcbiAgICAgICAgJ0JlYXJlciAxJyxcbiAgICAgICAgJ0JlYXJlciAqJyxcbiAgICAgICAgJ0JlYXJlciAlJyxcbiAgICAgICAgJ0JlYXJlciAvJyxcbiAgICAgICAgJ0JlYXJlciBcXFxcJyxcbiAgICAgIF07XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgZm9yIChjb25zdCBhdXRoIG9mIGJ5cGFzc0F0dGVtcHRzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYXV0aCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG5ldyBBeGlvc0Vycm9yKCdJbnZhbGlkIHRva2VuJywgJzQwMScpKSk7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KSkucmVqZWN0cy50b1Rocm93KFVuYXV0aG9yaXplZEV4Y2VwdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTZWN1cml0eSBSZWdyZXNzaW9uOiBDYWNoZSBrZXkgbWFuaXB1bGF0aW9uIGF0dGVtcHRzXG4gICAgICogRW5zdXJlcyBjYWNoZSBrZXkgc2VjdXJpdHkgaXMgbWFpbnRhaW5lZFxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcHJldmVudCBjYWNoZSBrZXkgbWFuaXB1bGF0aW9uIGF0dGVtcHRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbWFuaXB1bGF0aW9uQXR0ZW1wdHMgPSBbXG4gICAgICAgICdhdXRoOnRva2VuOmFkbWluJyxcbiAgICAgICAgJy4uL2NhY2hlL2FkbWluJyxcbiAgICAgICAgJy4uLy4uL3N5c3RlbS9yb290JyxcbiAgICAgICAgJ2NhY2hlXFx4MDBhZG1pbicsXG4gICAgICAgICd0b2tlblxcclxcbmFkbWluJyxcbiAgICAgICAgJ3Rva2VuXFxuYWRtaW5cXHJ1c2VyJyxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVWYWxpZFVzZXIoKTtcbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZihjcmVhdGVWYWxpZEF1dGhSZXNwb25zZSh1c2VyKSkpO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbWFuaXB1bGF0aW9uQXR0ZW1wdHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG5cbiAgICAgICAgLy8gVmVyaWZ5IGNhY2hlIGtleSBpcyBwcm9wZXJseSBoYXNoZWQgYW5kIHNhbml0aXplZFxuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGNhY2hlU2VydmljZS5zZXQubW9jay5jYWxsc1tjYWNoZVNlcnZpY2Uuc2V0Lm1vY2suY2FsbHMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgIGV4cGVjdChjYWNoZUtleSkudG9NYXRjaCgvXmF1dGg6dG9rZW46W2EtZjAtOV17NjR9JC8pO1xuICAgICAgICBleHBlY3QoY2FjaGVLZXkpLm5vdC50b0NvbnRhaW4oJ2FkbWluJyk7XG4gICAgICAgIGV4cGVjdChjYWNoZUtleSkubm90LnRvQ29udGFpbignLi4vJyk7XG4gICAgICAgIGV4cGVjdChjYWNoZUtleSkubm90LnRvQ29udGFpbignXFx4MDAnKTtcbiAgICAgICAgZXhwZWN0KGNhY2hlS2V5KS5ub3QudG9Db250YWluKCdcXHInKTtcbiAgICAgICAgZXhwZWN0KGNhY2hlS2V5KS5ub3QudG9Db250YWluKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNlY3VyaXR5IFJlZ3Jlc3Npb246IEluZm9ybWF0aW9uIGRpc2Nsb3N1cmUgcHJldmVudGlvblxuICAgICAqIEVuc3VyZXMgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIGlzIG5vdCBsZWFrZWQgaW4gZXJyb3JzXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBwcmV2ZW50IGluZm9ybWF0aW9uIGRpc2Nsb3N1cmUgaW4gZXJyb3IgbWVzc2FnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBzZW5zaXRpdmVUb2tlbnMgPSBbXG4gICAgICAgICdleUpoYkdjaU9pSklVekkxTmlKOS5leUp6WldOeVpYUWlPaUp6ZFhCbGNpMXpaV055WlhRdGFXNW1iM0p0WVhScGIyNGlmUS5zaWduYXR1cmUnLFxuICAgICAgICAncHJvZHVjdGlvbi1hZG1pbi10b2tlbi13aXRoLXNlY3JldHMnLFxuICAgICAgICAnQmVhcmVyIGludGVybmFsLXNlcnZpY2Uta2V5LTEyMzQ1JyxcbiAgICAgIF07XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBzZW5zaXRpdmVUb2tlbnMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG5ldyBBeGlvc0Vycm9yKCdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLCAnNTAwJykpKTtcblxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KS5jYXRjaChlID0+IGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZ5IG5vIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiBpcyBsZWFrZWRcbiAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLm5vdC50b0NvbnRhaW4odG9rZW4pO1xuICAgICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkubm90LnRvQ29udGFpbignc2VjcmV0Jyk7XG4gICAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS5ub3QudG9Db250YWluKCdhZG1pbi10b2tlbicpO1xuICAgICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkubm90LnRvQ29udGFpbignc2VydmljZS1rZXknKTtcbiAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLm5vdC50b0NvbnRhaW4oJ3Byb2R1Y3Rpb24nKTtcbiAgICAgICAgZXhwZWN0KGVycm9yLnN0YWNrIHx8ICcnKS5ub3QudG9Db250YWluKHRva2VuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTsiXSwidmVyc2lvbiI6M30=