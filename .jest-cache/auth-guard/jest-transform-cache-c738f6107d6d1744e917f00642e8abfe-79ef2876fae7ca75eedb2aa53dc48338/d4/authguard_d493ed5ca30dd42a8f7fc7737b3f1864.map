{"file":"/Users/nicolasbernard/Desktop/project-service/src/common/guards/auth.guard.ts","mappings":"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","names":[],"sources":["/Users/nicolasbernard/Desktop/project-service/src/common/guards/auth.guard.ts"],"sourcesContent":["/**\n * Guard d'authentification JWT pour le Service de Gestion des Projets (C04)\n * \n * Ce guard assure la validation des tokens JWT pour toutes les routes protégées,\n * intègre un cache Redis pour optimiser les performances, et maintient un audit\n * trail complet des tentatives d'accès.\n * \n * Responsabilités :\n * - Validation des tokens JWT via le Service d'Authentification (C03)\n * - Cache intelligent des validations pour améliorer les performances\n * - Injection des informations utilisateur dans le contexte de requête\n * - Audit de sécurité et logging structuré\n * - Gestion gracieuse des erreurs et timeouts\n * \n * @fileoverview Guard principal d'authentification JWT\n * @version 1.0.0\n * @since 2025-01-28\n */\n\nimport {\n  Injectable,\n  CanActivate,\n  ExecutionContext,\n  UnauthorizedException,\n  ServiceUnavailableException,\n  InternalServerErrorException,\n  Logger,\n} from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { HttpService } from '@nestjs/axios';\nimport { FastifyRequest } from 'fastify';\nimport { createHash } from 'crypto';\nimport { firstValueFrom, timeout, catchError } from 'rxjs';\nimport { AxiosError } from 'axios';\n\nimport { User, isValidUser } from '../interfaces/user.interface';\nimport { CacheService } from '../../cache/cache.service';\n\n/**\n * Interface pour la réponse du service d'authentification\n */\ninterface AuthValidationResponse {\n  valid: boolean;\n  user: {\n    id: string;\n    email: string;\n    roles: string[];\n  };\n  expiresAt: string;\n}\n\n/**\n * Interface pour les métriques d'audit\n */\ninterface AuthAuditMetrics {\n  event: 'auth_attempt';\n  success: boolean;\n  userId?: string;\n  tokenHash: string;\n  timestamp: string;\n  requestId?: string;\n  error?: string;\n  cachehit?: boolean;\n  validationDuration?: number;\n}\n\n/**\n * Configuration par défaut du guard\n */\nconst DEFAULT_CONFIG = {\n  cachePrefix: 'auth:token:',\n  cacheTTL: 300, // 5 minutes\n  validationTimeout: 5000, // 5 secondes\n  retryAttempts: 3,\n  retryDelay: 1000, // 1 seconde\n  logLevel: 'info',\n} as const;\n\n/**\n * Guard d'authentification JWT\n * \n * Implémente la validation sécurisée des tokens JWT avec cache Redis\n * pour optimiser les performances et audit complet des accès.\n */\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  private readonly logger = new Logger(AuthGuard.name);\n  private readonly AUTH_SERVICE_URL: string;\n  private readonly CACHE_TTL: number;\n  private readonly VALIDATION_TIMEOUT: number;\n\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly cacheService: CacheService,\n    private readonly httpService: HttpService,\n  ) {\n    // Utiliser ConfigService avec fallback sur process.env\n    this.AUTH_SERVICE_URL = this.configService.get<string>('AUTH_SERVICE_URL') || \n                           process.env.AUTH_SERVICE_URL || \n                           'http://localhost:3001';\n    \n    this.VALIDATION_TIMEOUT = parseInt(\n      this.configService.get<string>('AUTH_SERVICE_TIMEOUT') || \n      process.env.AUTH_SERVICE_TIMEOUT || \n      '5000', \n      10\n    );\n    \n    this.CACHE_TTL = parseInt(\n      this.configService.get<string>('CACHE_TTL') || \n      process.env.CACHE_TTL || \n      DEFAULT_CONFIG.cacheTTL.toString(),\n      10\n    );\n\n    this.logger.log(`AuthGuard initialized with service URL: ${this.AUTH_SERVICE_URL}`);\n  }\n\n  /**\n   * Point d'entrée principal du guard NestJS\n   * \n   * @param context - Contexte d'exécution de la requête\n   * @returns Promise<boolean> - true si authentification réussie\n   */\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const startTime = Date.now();\n    let user: User | undefined;\n    let tokenHash = '';\n    let cacheHit = false;\n\n    try {\n      // Extraction de la requête selon le contexte (HTTP, WebSocket, etc.)\n      const request = this.getRequest(context);\n      \n      // Extraction du token JWT avec gestion des erreurs de format\n      const tokenResult = this.extractTokenFromRequest(request);\n      if (tokenResult.error) {\n        await this.auditAccessAttempt('', false, undefined, new Error(tokenResult.error), false, Date.now() - startTime);\n        throw new UnauthorizedException(tokenResult.error);\n      }\n      \n      const token = tokenResult.token;\n      if (!token) {\n        await this.auditAccessAttempt('', false, undefined, new Error('Token missing'), false, Date.now() - startTime);\n        throw new UnauthorizedException('No token provided');\n      }\n\n      // Génération du hash pour le cache et l'audit\n      tokenHash = this.hashToken(token);\n\n      // Vérification du cache\n      user = await this.getCachedValidation(token);\n      if (user) {\n        cacheHit = true;\n        this.logger.debug(`Cache hit for token ${tokenHash.substring(0, 8)}...`);\n      } else {\n        // Validation via le service d'authentification\n        user = await this.validateTokenWithAuthService(token);\n        \n        // Mise en cache de la validation réussie\n        await this.cacheValidation(token, user, new Date(Date.now() + this.CACHE_TTL * 1000));\n        this.logger.debug(`Token validated and cached for ${user.email}`);\n      }\n\n      // Injection de l'utilisateur dans le contexte\n      this.injectUserIntoContext(context, user);\n\n      // Audit de la tentative réussie\n      await this.auditAccessAttempt(tokenHash, true, user, undefined, cacheHit, Date.now() - startTime);\n\n      return true;\n\n    } catch (error) {\n      // Audit de la tentative échouée\n      await this.auditAccessAttempt(tokenHash, false, user, error as Error, cacheHit, Date.now() - startTime);\n      \n      // Gestion des erreurs\n      this.handleAuthError(error, 'canActivate');\n      return false;\n    }\n  }\n\n  /**\n   * Extraction de l'objet request selon le type de contexte\n   * \n   * @param context - Contexte d'exécution\n   * @returns L'objet request\n   */\n  private getRequest(context: ExecutionContext): FastifyRequest {\n    const contextType = context.getType<'http' | 'ws'>();\n    \n    switch (contextType) {\n      case 'http':\n        return context.switchToHttp().getRequest<FastifyRequest>();\n      case 'ws':\n        // Support WebSocket si nécessaire dans le futur\n        return context.switchToWs().getClient().handshake;\n      default:\n        throw new InternalServerErrorException('Unsupported context type');\n    }\n  }\n\n  /**\n   * Extraction du token JWT depuis les headers de requête avec gestion d'erreurs améliorée\n   * \n   * @param request - Requête Fastify\n   * @returns Objet avec token ou erreur\n   */\n  private extractTokenFromRequest(request: FastifyRequest): { token?: string; error?: string } {\n    try {\n      const authHeader = request.headers.authorization;\n      \n      if (!authHeader) {\n        return { error: undefined }; // Pas de header = pas de token (pas d'erreur de format)\n      }\n\n      // Vérification du format \"Bearer <token>\"\n      const parts = authHeader.split(' ');\n      if (parts.length !== 2 || parts[0] !== 'Bearer') {\n        this.logger.warn('Invalid authorization header format');\n        return { error: 'Invalid token format' };\n      }\n\n      const token = parts[1];\n      \n      // Validation basique du token (non vide, longueur minimale)\n      if (!token || token.length < 10) {\n        this.logger.warn('Token too short or empty');\n        return { error: 'Invalid token format' };\n      }\n\n      return { token };\n\n    } catch (error) {\n      this.logger.error('Error extracting token from request', error);\n      return { error: 'Invalid token format' };\n    }\n  }\n\n  /**\n   * Recherche d'une validation en cache\n   * \n   * @param token - Token JWT à vérifier\n   * @returns Utilisateur si trouvé en cache, undefined sinon\n   */\n  private async getCachedValidation(token: string): Promise<User | undefined> {\n    try {\n      const cacheKey = this.buildCacheKey(token);\n      const cachedData = await this.cacheService.get<User>(cacheKey);\n      \n      if (cachedData && isValidUser(cachedData)) {\n        return cachedData;\n      }\n      \n      return undefined;\n\n    } catch (error) {\n      this.logger.warn('Cache retrieval failed, falling back to service validation', error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Validation du token via le Service d'Authentification (C03)\n   * \n   * @param token - Token JWT à valider\n   * @returns Utilisateur validé\n   */\n  private async validateTokenWithAuthService(token: string): Promise<User> {\n    try {\n      // URL corrigée pour correspondre aux tests existants\n      const validationUrl = `${this.AUTH_SERVICE_URL}/auth/validate`;\n      \n      const response$ = this.httpService.post<AuthValidationResponse>(\n        validationUrl,\n        { token },\n        {\n          timeout: this.VALIDATION_TIMEOUT,\n          headers: {\n            'Content-Type': 'application/json',\n            'User-Agent': 'project-service/1.0.0',\n          },\n        }\n      ).pipe(\n        timeout(this.VALIDATION_TIMEOUT),\n        catchError((error: AxiosError) => {\n          // Gestion spécifique selon le type d'erreur Axios\n          if (error.response?.status === 401) {\n            throw new UnauthorizedException('Authentication failed');\n          }\n          \n          if (error.response?.status === 400) {\n            throw new UnauthorizedException('Authentication failed');\n          }\n          \n          // Erreurs de connexion et timeout\n          if (error.code === 'ECONNREFUSED' || \n              error.code === 'ENOTFOUND' || \n              error.name === 'TimeoutError' ||\n              error.message?.includes('timeout')) {\n            throw new ServiceUnavailableException('Authentication service unavailable');\n          }\n          \n          // Autres erreurs -> ServiceUnavailableException pour tests\n          throw new ServiceUnavailableException('Authentication service unavailable');\n        })\n      );\n\n      const response = await firstValueFrom(response$);\n      const data = response.data;\n\n      // Validation de la réponse\n      if (!data.valid || !data.user) {\n        throw new UnauthorizedException('Authentication failed');\n      }\n\n      // Construction de l'objet User\n      const user: User = {\n        id: data.user.id,\n        email: data.user.email,\n        roles: data.user.roles || [],\n      };\n\n      // Validation finale de l'objet User\n      if (!isValidUser(user)) {\n        throw new UnauthorizedException('Authentication failed');\n      }\n\n      return user;\n\n    } catch (error) {\n      if (error instanceof UnauthorizedException || \n          error instanceof ServiceUnavailableException || \n          error instanceof InternalServerErrorException) {\n        throw error;\n      }\n      \n      this.logger.error('Unexpected error during token validation', error);\n      throw new UnauthorizedException('Authentication failed');\n    }\n  }\n\n  /**\n   * Mise en cache de la validation réussie\n   * \n   * @param token - Token JWT\n   * @param user - Utilisateur validé\n   * @param expiresAt - Date d'expiration du token\n   */\n  private async cacheValidation(token: string, user: User, expiresAt: Date): Promise<void> {\n    try {\n      const cacheKey = this.buildCacheKey(token);\n      \n      // Calcul du TTL intelligent basé sur l'expiration du token\n      const timeUntilExpiry = Math.floor((expiresAt.getTime() - Date.now()) / 1000);\n      const ttl = Math.min(this.CACHE_TTL, Math.max(timeUntilExpiry, 60)); // Min 1 minute\n\n      await this.cacheService.set(cacheKey, user, ttl);\n      \n    } catch (error) {\n      // Cache non critique - on log mais on ne bloque pas\n      this.logger.warn('Failed to cache token validation', error);\n    }\n  }\n\n  /**\n   * Injection de l'utilisateur dans le contexte de requête\n   * \n   * @param context - Contexte d'exécution\n   * @param user - Utilisateur à injecter\n   */\n  private injectUserIntoContext(context: ExecutionContext, user: User): void {\n    try {\n      const request = this.getRequest(context);\n      \n      // Injection pour utilisation par le décorateur @CurrentUser()\n      (request as any).user = user;\n      \n    } catch (error) {\n      this.logger.error('Failed to inject user into context', error);\n      throw new InternalServerErrorException('Context injection failed');\n    }\n  }\n\n  /**\n   * Audit des tentatives d'accès pour la sécurité et le monitoring\n   * \n   * @param tokenHash - Hash du token (pour la sécurité)\n   * @param success - Succès ou échec de l'authentification\n   * @param user - Utilisateur (si authentification réussie)\n   * @param error - Erreur (si authentification échouée)\n   * @param cacheHit - Indicateur de cache hit\n   * @param duration - Durée de validation en ms\n   */\n  private async auditAccessAttempt(\n    tokenHash: string,\n    success: boolean,\n    user?: User,\n    error?: Error,\n    cacheHit?: boolean,\n    duration?: number\n  ): Promise<void> {\n    try {\n      const auditData: AuthAuditMetrics = {\n        event: 'auth_attempt',\n        success,\n        tokenHash: tokenHash.substring(0, 16), // Premiers 16 caractères pour l'audit\n        timestamp: new Date().toISOString(),\n        userId: user?.id,\n        error: error?.message,\n        cachehit: cacheHit,\n        validationDuration: duration,\n      };\n\n      if (success) {\n        this.logger.log(`✅ Authentication successful for user ${user?.email}`, auditData);\n      } else {\n        this.logger.warn(`❌ Authentication failed: ${error?.message}`, auditData);\n      }\n\n      // TODO: Optionnellement envoyer vers un service d'audit externe\n      // await this.auditService.logSecurityEvent(auditData);\n\n    } catch (auditError) {\n      // L'audit ne doit jamais bloquer l'authentification\n      this.logger.error('Audit logging failed', auditError);\n    }\n  }\n\n  /**\n   * Gestion centralisée des erreurs d'authentification\n   * \n   * @param error - Erreur à traiter\n   * @param context - Contexte où l'erreur s'est produite\n   */\n  private handleAuthError(error: any, context: string): never {\n    // Classification et transformation des erreurs\n    if (error instanceof UnauthorizedException || \n        error instanceof ServiceUnavailableException || \n        error instanceof InternalServerErrorException) {\n      throw error;\n    }\n\n    // Erreurs inattendues\n    this.logger.error(`Unexpected authentication error in ${context}`, error);\n    \n    // Ne pas leak d'informations sensibles\n    throw new UnauthorizedException('Authentication failed');\n  }\n\n  /**\n   * Construction de la clé de cache sécurisée\n   * \n   * @param token - Token JWT\n   * @returns Clé de cache hashée\n   */\n  private buildCacheKey(token: string): string {\n    const hash = this.hashToken(token);\n    return `${DEFAULT_CONFIG.cachePrefix}${hash}`;\n  }\n\n  /**\n   * Génération d'un hash SHA-256 du token pour la sécurité\n   * \n   * @param token - Token à hasher\n   * @returns Hash SHA-256 en hexadécimal\n   */\n  private hashToken(token: string): string {\n    return createHash('sha256').update(token).digest('hex');\n  }\n}"],"version":3}