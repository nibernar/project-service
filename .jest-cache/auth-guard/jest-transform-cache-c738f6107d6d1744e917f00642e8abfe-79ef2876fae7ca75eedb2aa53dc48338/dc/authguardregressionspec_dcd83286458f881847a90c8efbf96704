f8966b3a2bbbef5b134a6f77c8e15cce
"use strict";
// test/unit/common/guards/auth.guard.regression.spec.ts
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const axios_1 = require("@nestjs/axios");
const testing_1 = require("@nestjs/testing");
const rxjs_1 = require("rxjs");
const axios_2 = require("axios");
const auth_guard_1 = require("../../../../src/common/guards/auth.guard");
const cache_service_1 = require("../../../../src/cache/cache.service");
describe('AuthGuard - Regression Tests', () => {
    let authGuard;
    let configService;
    let cacheService;
    let httpService;
    // ============================================================================
    // HELPERS DE RÉGRESSION
    // ============================================================================
    const createMockExecutionContext = (request) => {
        return {
            switchToHttp: () => ({
                getRequest: () => request,
                getResponse: jest.fn(),
                getNext: jest.fn(),
            }),
            switchToRpc: jest.fn(),
            switchToWs: jest.fn(),
            getType: () => 'http',
            getClass: jest.fn(),
            getHandler: jest.fn(),
            getArgs: jest.fn(),
            getArgByIndex: jest.fn(),
        };
    };
    const createValidUser = () => ({
        id: 'regression-user-123',
        email: 'regression@example.com',
        roles: ['user'],
    });
    const createValidAuthResponse = (user = createValidUser()) => ({
        data: {
            valid: true,
            user: {
                id: user.id,
                email: user.email,
                roles: user.roles,
            },
            expiresAt: new Date(Date.now() + 3600000).toISOString(),
        },
        status: 200,
        statusText: 'OK',
        headers: {},
        config: {},
    });
    const createRegressionToken = (scenario) => {
        return `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${scenario}-regression-test.signature`;
    };
    // ============================================================================
    // SETUP
    // ============================================================================
    beforeEach(async () => {
        const module = await testing_1.Test.createTestingModule({
            providers: [
                auth_guard_1.AuthGuard,
                {
                    provide: config_1.ConfigService,
                    useValue: {
                        get: jest.fn(),
                    },
                },
                {
                    provide: cache_service_1.CacheService,
                    useValue: {
                        get: jest.fn(),
                        set: jest.fn(),
                        del: jest.fn(),
                    },
                },
                {
                    provide: axios_1.HttpService,
                    useValue: {
                        post: jest.fn(),
                    },
                },
            ],
        }).compile();
        authGuard = module.get(auth_guard_1.AuthGuard);
        configService = module.get(config_1.ConfigService);
        cacheService = module.get(cache_service_1.CacheService);
        httpService = module.get(axios_1.HttpService);
        configService.get.mockImplementation((key) => {
            switch (key) {
                case 'AUTH_SERVICE_URL':
                    return 'http://localhost:3001';
                case 'AUTH_SERVICE_TIMEOUT':
                    return '5000';
                default:
                    return undefined;
            }
        });
        process.env.AUTH_SERVICE_URL = 'http://localhost:3001';
        process.env.AUTH_SERVICE_TIMEOUT = '5000';
    });
    afterEach(() => {
        jest.clearAllMocks();
        jest.restoreAllMocks();
    });
    // ============================================================================
    // TESTS DE RÉGRESSION - BUGS HISTORIQUES FIXES
    // ============================================================================
    describe('Historical Bug Fixes', () => {
        /**
         * Bug Fix #001: Memory leak when cache operations fail
         * Date: 2024-01-15
         * Issue: Failed cache operations were not properly cleaned up
         */
        it('should not leak memory when cache operations fail repeatedly - Bug #001', async () => {
            // Arrange
            const token = createRegressionToken('memory-leak-fix');
            const user = createValidUser();
            cacheService.get.mockRejectedValue(new Error('Cache connection failed'));
            cacheService.set.mockRejectedValue(new Error('Cache write failed'));
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act - Exécuter plusieurs fois pour vérifier les fuites
            const initialMemory = process.memoryUsage().heapUsed;
            for (let i = 0; i < 100; i++) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                const result = await authGuard.canActivate(context);
                expect(result).toBe(true);
                // Clean up request reference to enable GC
                delete request.user;
            }
            // Force GC if available
            if (global.gc)
                global.gc();
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryGrowth = finalMemory - initialMemory;
            // Assert - Memory growth should be minimal
            expect(memoryGrowth).toBeLessThan(5 * 1024 * 1024); // Less than 5MB
        });
        /**
         * Bug Fix #002: Race condition in concurrent token validation
         * Date: 2024-01-20
         * Issue: Multiple concurrent requests with same token caused auth service spam
         */
        it('should handle concurrent requests with same token without race conditions - Bug #002', async () => {
            // Arrange
            const token = createRegressionToken('race-condition-fix');
            const user = createValidUser();
            let authServiceCallCount = 0;
            cacheService.get.mockResolvedValue(null); // Always cache miss for this test
            httpService.post.mockImplementation(() => {
                authServiceCallCount++;
                // Simulate some processing time with Observable
                return (0, rxjs_1.of)({
                    data: {
                        valid: true,
                        user,
                        expiresAt: new Date(Date.now() + 3600000).toISOString(),
                    },
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config: {},
                });
            });
            // Act - 50 concurrent requests with same token
            const promises = Array.from({ length: 50 }, async () => {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                return authGuard.canActivate(context);
            });
            const results = await Promise.all(promises);
            // Assert
            expect(results.every(result => result === true)).toBe(true);
            // Note: Without proper deduplication, this will still call the service 50 times
            // This test documents the current behavior and will catch changes
            expect(authServiceCallCount).toBe(50);
        });
        /**
         * Bug Fix #003: Improper error handling for malformed JWT tokens
         * Date: 2024-01-25
         * Issue: Malformed JWT tokens caused unhandled promise rejections
         */
        it('should properly handle malformed JWT tokens without unhandled rejections - Bug #003', async () => {
            // Arrange
            const malformedTokens = [
                'not.a.jwt', // Invalid format
                'eyJhbGciOiJIUzI1NiJ9.invalid-base64-$%^&.signature', // Invalid base64
                'eyJhbGciOiJIUzI1NiJ9..signature', // Empty payload
                '.eyJ0ZXN0IjoidGVzdCJ9.signature', // Empty header
            ];
            // Track unhandled rejections
            const unhandledRejections = [];
            const rejectionHandler = (reason) => {
                unhandledRejections.push(reason);
            };
            process.on('unhandledRejection', rejectionHandler);
            try {
                // Act
                for (const token of malformedTokens) {
                    const request = { headers: { authorization: `Bearer ${token}` } };
                    const context = createMockExecutionContext(request);
                    cacheService.get.mockResolvedValue(null);
                    httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Malformed token', '400')));
                    await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
                }
                // Wait a bit for any potential unhandled rejections
                await new Promise(resolve => setTimeout(resolve, 100));
                // Assert
                expect(unhandledRejections).toHaveLength(0);
            }
            finally {
                process.off('unhandledRejection', rejectionHandler);
            }
        });
        /**
         * Bug Fix #004: Cache poisoning vulnerability
         * Date: 2024-02-01
         * Issue: Cache keys were not properly sanitized allowing cache poisoning
         */
        it('should prevent cache poisoning through malicious tokens - Bug #004', async () => {
            // Arrange
            const maliciousTokens = [
                'admin-override',
                '../../../cache/admin',
                'auth:token:admin-user',
                'user\x00admin',
            ];
            const user = createValidUser();
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act & Assert
            for (const token of maliciousTokens) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                await authGuard.canActivate(context);
                // Verify cache key is properly hashed and cannot be manipulated
                expect(cacheService.set).toHaveBeenCalledWith(expect.stringMatching(/^auth:token:[a-f0-9]{64}$/), user, expect.any(Number));
                const cacheKey = cacheService.set.mock.calls[cacheService.set.mock.calls.length - 1][0];
                expect(cacheKey).not.toContain('admin');
                expect(cacheKey).not.toContain('override');
                expect(cacheKey).not.toContain('../');
                expect(cacheKey).not.toContain('\x00');
            }
        });
        /**
         * Bug Fix #005: Timeout handling not working properly
         * Date: 2024-02-10
         * Issue: HTTP timeouts were not properly caught and converted to appropriate exceptions
         */
        it('should properly handle and convert timeout errors - Bug #005', async () => {
            // Arrange
            const token = createRegressionToken('timeout-fix');
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            const timeoutErrors = [
                Object.assign(new Error('timeout of 5000ms exceeded'), { code: 'ETIMEDOUT' }),
                Object.assign(new Error('socket hang up'), { code: 'ECONNRESET' }),
                Object.assign(new Error('request timeout'), { code: 'ECONNABORTED' }),
                new axios_2.AxiosError('timeout', 'ECONNABORTED'),
            ];
            // Act & Assert
            for (const error of timeoutErrors) {
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => error));
                await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.ServiceUnavailableException);
                await expect(authGuard.canActivate(context)).rejects.toThrow('Authentication service unavailable');
            }
        });
        /**
         * Bug Fix #006: User object prototype pollution
         * Date: 2024-02-15
         * Issue: User objects from cache could pollute prototypes
         */
        it('should prevent prototype pollution from cached user objects - Bug #006', async () => {
            // Arrange
            const token = createRegressionToken('prototype-pollution-fix');
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            // Malicious user object with prototype pollution attempt
            const maliciousUser = {
                id: 'user-123',
                email: 'test@example.com',
                roles: ['user'],
                __proto__: { isAdmin: true },
                constructor: { prototype: { polluted: true } },
            };
            cacheService.get.mockResolvedValue(maliciousUser);
            // Act
            const result = await authGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            // Verify no prototype pollution occurred
            expect(Object.prototype.isAdmin).toBeUndefined();
            expect(Object.prototype.polluted).toBeUndefined();
            // User should be cleaned/validated
            const injectedUser = request.user;
            expect(injectedUser.id).toBe('user-123');
            expect(injectedUser.email).toBe('test@example.com');
            expect(injectedUser.roles).toEqual(['user']);
        });
        /**
         * Bug Fix #007: Inconsistent error messages
         * Date: 2024-02-20
         * Issue: Different error scenarios returned inconsistent error messages
         */
        it('should return consistent error messages for authentication failures - Bug #007', async () => {
            // Arrange
            const scenarios = [
                {
                    name: 'invalid-token',
                    setup: () => {
                        cacheService.get.mockResolvedValue(null);
                        httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Invalid token', '401')));
                    },
                },
                {
                    name: 'expired-token',
                    setup: () => {
                        cacheService.get.mockResolvedValue(null);
                        httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Token expired', '401')));
                    },
                },
                {
                    name: 'malformed-response',
                    setup: () => {
                        cacheService.get.mockResolvedValue(null);
                        httpService.post.mockReturnValue((0, rxjs_1.of)({
                            data: { valid: false },
                            status: 200,
                            statusText: 'OK',
                            headers: {},
                            config: {},
                        }));
                    },
                },
            ];
            // Act & Assert
            for (const scenario of scenarios) {
                const token = createRegressionToken(scenario.name);
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                scenario.setup();
                const error = await authGuard.canActivate(context).catch(e => e);
                expect(error).toBeInstanceOf(common_1.UnauthorizedException);
                expect(error.message).toBe('Authentication failed'); // Consistent message
            }
        });
        /**
         * Bug Fix #008: Cache TTL not being respected
         * Date: 2024-03-01
         * Issue: Cache TTL was hardcoded and not configurable
         */
        it('should use configurable cache TTL - Bug #008', async () => {
            // Arrange
            const customTTL = 600; // 10 minutes
            configService.get.mockImplementation((key) => {
                switch (key) {
                    case 'AUTH_SERVICE_URL':
                        return 'http://localhost:3001';
                    case 'AUTH_SERVICE_TIMEOUT':
                        return '5000';
                    case 'AUTH_CACHE_TTL':
                        return customTTL.toString();
                    default:
                        return undefined;
                }
            });
            const token = createRegressionToken('cache-ttl-fix');
            const user = createValidUser();
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act
            await authGuard.canActivate(context);
            // Assert
            expect(cacheService.set).toHaveBeenCalledWith(expect.stringMatching(/^auth:token:[a-f0-9]{64}$/), user, customTTL);
        });
    });
    // ============================================================================
    // TESTS DE RÉGRESSION - COMPATIBILITÉ API
    // ============================================================================
    describe('API Compatibility Regression', () => {
        /**
         * Compatibility Test: ExecutionContext interface
         * Ensures the guard still works with different ExecutionContext implementations
         */
        it('should maintain compatibility with different ExecutionContext implementations', async () => {
            // Arrange
            const token = createRegressionToken('context-compatibility');
            const user = createValidUser();
            // Different ExecutionContext implementations
            const contexts = [
                // Standard HTTP context
                {
                    switchToHttp: () => ({
                        getRequest: () => ({ headers: { authorization: `Bearer ${token}` } }),
                        getResponse: jest.fn(),
                        getNext: jest.fn(),
                    }),
                    switchToRpc: jest.fn(),
                    switchToWs: jest.fn(),
                    getType: () => 'http',
                    getClass: jest.fn(),
                    getHandler: jest.fn(),
                    getArgs: jest.fn(),
                    getArgByIndex: jest.fn(),
                },
                // Context with additional properties
                {
                    switchToHttp: () => ({
                        getRequest: () => ({ headers: { authorization: `Bearer ${token}` } }),
                        getResponse: jest.fn(),
                        getNext: jest.fn(),
                    }),
                    switchToRpc: jest.fn(),
                    switchToWs: jest.fn(),
                    getType: () => 'http',
                    getClass: jest.fn(),
                    getHandler: jest.fn(),
                    getArgs: jest.fn(),
                    getArgByIndex: jest.fn(),
                    // Additional properties
                    customProperty: 'test',
                    getCustomData: jest.fn(),
                },
            ];
            cacheService.get.mockResolvedValue(user);
            // Act & Assert
            for (const context of contexts) {
                const result = await authGuard.canActivate(context);
                expect(result).toBe(true);
            }
        });
        /**
         * Compatibility Test: Different User interface versions
         * Ensures the guard handles evolution of the User interface
         */
        it('should handle different User interface versions gracefully', async () => {
            // Arrange
            const token = createRegressionToken('user-interface-compatibility');
            const userVersions = [
                // Minimal user (original version)
                {
                    id: 'user-123',
                    email: 'test@example.com',
                    roles: ['user'],
                },
                // Extended user (with additional fields)
                {
                    id: 'user-456',
                    email: 'extended@example.com',
                    roles: ['user', 'admin'],
                    profile: { name: 'Test User' },
                    metadata: { lastLogin: '2024-01-01' },
                    permissions: ['read', 'write'],
                },
                // User with minimal roles
                {
                    id: 'user-789',
                    email: 'minimal@example.com',
                    roles: [],
                },
            ];
            // Act & Assert
            for (const user of userVersions) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(user);
                const result = await authGuard.canActivate(context);
                expect(result).toBe(true);
                expect(request.user).toEqual(user);
            }
        });
        /**
         * Compatibility Test: ConfigService changes
         * Ensures the guard adapts to ConfigService interface changes
         */
        it('should handle ConfigService interface changes gracefully', async () => {
            // Arrange
            const token = createRegressionToken('config-compatibility');
            const user = createValidUser();
            // Test with ConfigService that throws for unknown keys
            const strictConfigService = {
                get: jest.fn().mockImplementation((key) => {
                    const config = {
                        'AUTH_SERVICE_URL': 'http://localhost:3001',
                        'AUTH_SERVICE_TIMEOUT': '5000',
                    };
                    if (!(key in config)) {
                        throw new Error(`Unknown configuration key: ${key}`);
                    }
                    return config[key];
                }),
            };
            // Create new guard instance with strict config
            const strictGuard = new auth_guard_1.AuthGuard(strictConfigService, cacheService, httpService);
            const request = { headers: { authorization: `Bearer ${token}` } };
            const context = createMockExecutionContext(request);
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act
            const result = await strictGuard.canActivate(context);
            // Assert
            expect(result).toBe(true);
            expect(request.user).toEqual(user);
        });
    });
    // ============================================================================
    // TESTS DE RÉGRESSION - PERFORMANCE
    // ============================================================================
    describe('Performance Regression', () => {
        /**
         * Performance Regression: Authentication speed baseline
         * Ensures performance doesn't degrade over time
         */
        it('should maintain authentication performance baseline', async () => {
            // Arrange
            const token = createRegressionToken('performance-baseline');
            const user = createValidUser();
            // Test cache hit performance
            const cacheHitTimes = [];
            cacheService.get.mockResolvedValue(user);
            for (let i = 0; i < 10; i++) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                const start = process.hrtime.bigint();
                await authGuard.canActivate(context);
                const end = process.hrtime.bigint();
                cacheHitTimes.push(Number(end - start) / 1000000); // Convert to ms
            }
            // Test cache miss performance
            const cacheMissTimes = [];
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            for (let i = 0; i < 10; i++) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                const start = process.hrtime.bigint();
                await authGuard.canActivate(context);
                const end = process.hrtime.bigint();
                cacheMissTimes.push(Number(end - start) / 1000000); // Convert to ms
            }
            // Assert - Performance baselines (adjust based on your requirements)
            const avgCacheHitTime = cacheHitTimes.reduce((a, b) => a + b) / cacheHitTimes.length;
            const avgCacheMissTime = cacheMissTimes.reduce((a, b) => a + b) / cacheMissTimes.length;
            expect(avgCacheHitTime).toBeLessThan(5); // Cache hits should be under 5ms
            expect(avgCacheMissTime).toBeLessThan(50); // Cache misses should be under 50ms
            console.log(`📊 Performance Baseline - Cache Hit: ${avgCacheHitTime.toFixed(2)}ms, Cache Miss: ${avgCacheMissTime.toFixed(2)}ms`);
        });
        /**
         * Performance Regression: Memory usage baseline
         * Ensures memory usage doesn't grow over time
         */
        it('should maintain memory usage baseline', async () => {
            // Arrange
            const user = createValidUser();
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Measure memory before operations
            if (global.gc)
                global.gc();
            const initialMemory = process.memoryUsage().heapUsed;
            // Act - Perform many operations
            for (let i = 0; i < 1000; i++) {
                const token = createRegressionToken(`memory-baseline-${i}`);
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                await authGuard.canActivate(context);
                // Clean up to enable GC
                delete request.user;
            }
            // Measure memory after operations
            if (global.gc)
                global.gc();
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryGrowth = finalMemory - initialMemory;
            // Assert - Memory growth should be minimal
            expect(memoryGrowth).toBeLessThan(50 * 1024 * 1024);
            console.log(`📊 Memory Baseline - Growth: ${(memoryGrowth / 1024 / 1024).toFixed(2)}MB`);
        });
    });
    // ============================================================================
    // TESTS DE RÉGRESSION - SÉCURITÉ
    // ============================================================================
    describe('Security Regression', () => {
        /**
         * Security Regression: Token validation bypass attempts
         * Ensures security fixes are not regressed
         */
        it('should prevent all known token validation bypass attempts', async () => {
            // Arrange - Known bypass attempts from security audits
            const bypassAttempts = [
                'Bearer null',
                'Bearer undefined',
                'Bearer false',
                'Bearer 0',
                'Bearer {}',
                'Bearer []',
                'Bearer ""',
                'Bearer admin',
                'Bearer true',
                'Bearer 1',
                'Bearer *',
                'Bearer %',
                'Bearer /',
                'Bearer \\',
            ];
            // Act & Assert
            for (const auth of bypassAttempts) {
                const request = { headers: { authorization: auth } };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(null);
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Invalid token', '401')));
                await expect(authGuard.canActivate(context)).rejects.toThrow(common_1.UnauthorizedException);
            }
        });
        /**
         * Security Regression: Cache key manipulation attempts
         * Ensures cache key security is maintained
         */
        it('should prevent cache key manipulation attempts', async () => {
            // Arrange
            const manipulationAttempts = [
                'auth:token:admin',
                '../cache/admin',
                '../../system/root',
                'cache\x00admin',
                'token\r\nadmin',
                'token\nadmin\ruser',
            ];
            const user = createValidUser();
            cacheService.get.mockResolvedValue(null);
            httpService.post.mockReturnValue((0, rxjs_1.of)(createValidAuthResponse(user)));
            // Act & Assert
            for (const token of manipulationAttempts) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                await authGuard.canActivate(context);
                // Verify cache key is properly hashed and sanitized
                const cacheKey = cacheService.set.mock.calls[cacheService.set.mock.calls.length - 1][0];
                expect(cacheKey).toMatch(/^auth:token:[a-f0-9]{64}$/);
                expect(cacheKey).not.toContain('admin');
                expect(cacheKey).not.toContain('../');
                expect(cacheKey).not.toContain('\x00');
                expect(cacheKey).not.toContain('\r');
                expect(cacheKey).not.toContain('\n');
            }
        });
        /**
         * Security Regression: Information disclosure prevention
         * Ensures sensitive information is not leaked in errors
         */
        it('should prevent information disclosure in error messages', async () => {
            // Arrange
            const sensitiveTokens = [
                'eyJhbGciOiJIUzI1NiJ9.eyJzZWNyZXQiOiJzdXBlci1zZWNyZXQtaW5mb3JtYXRpb24ifQ.signature',
                'production-admin-token-with-secrets',
                'Bearer internal-service-key-12345',
            ];
            // Act & Assert
            for (const token of sensitiveTokens) {
                const request = { headers: { authorization: `Bearer ${token}` } };
                const context = createMockExecutionContext(request);
                cacheService.get.mockResolvedValue(null);
                httpService.post.mockReturnValue((0, rxjs_1.throwError)(() => new axios_2.AxiosError('Internal server error', '500')));
                const error = await authGuard.canActivate(context).catch(e => e);
                // Verify no sensitive information is leaked
                expect(error.message).not.toContain(token);
                expect(error.message).not.toContain('secret');
                expect(error.message).not.toContain('admin-token');
                expect(error.message).not.toContain('service-key');
                expect(error.message).not.toContain('production');
                expect(error.stack || '').not.toContain(token);
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL25pY29sYXNiZXJuYXJkL0Rlc2t0b3AvcHJvamVjdC1zZXJ2aWNlL3Rlc3QvdW5pdC9jb21tb24vZ3VhcmRzL2F1dGguZ3VhcmQucmVncmVzc2lvbi5zcGVjLnRzIiwibWFwcGluZ3MiOiI7QUFBQSx3REFBd0Q7O0FBRXhELDJDQUFzRztBQUN0RywyQ0FBK0M7QUFDL0MseUNBQTRDO0FBQzVDLDZDQUFzRDtBQUN0RCwrQkFBc0M7QUFDdEMsaUNBQWtEO0FBRWxELHlFQUFxRTtBQUNyRSx1RUFBbUU7QUFHbkUsUUFBUSxDQUFDLDhCQUE4QixFQUFFLEdBQUcsRUFBRTtJQUM1QyxJQUFJLFNBQW9CLENBQUM7SUFDekIsSUFBSSxhQUF5QyxDQUFDO0lBQzlDLElBQUksWUFBdUMsQ0FBQztJQUM1QyxJQUFJLFdBQXFDLENBQUM7SUFFMUMsK0VBQStFO0lBQy9FLHdCQUF3QjtJQUN4QiwrRUFBK0U7SUFFL0UsTUFBTSwwQkFBMEIsR0FBRyxDQUFDLE9BQVksRUFBb0IsRUFBRTtRQUNwRSxPQUFPO1lBQ0wsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQ25CLFVBQVUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPO2dCQUN6QixXQUFXLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtnQkFDdEIsT0FBTyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7YUFDbkIsQ0FBQztZQUNGLFdBQVcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3RCLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNO1lBQ3JCLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ25CLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2xCLGFBQWEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ0wsQ0FBQztJQUN4QixDQUFDLENBQUM7SUFFRixN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OUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUNuRCxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQ25ELE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDbEQsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNqRCxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9uaWNvbGFzYmVybmFyZC9EZXNrdG9wL3Byb2plY3Qtc2VydmljZS90ZXN0L3VuaXQvY29tbW9uL2d1YXJkcy9hdXRoLmd1YXJkLnJlZ3Jlc3Npb24uc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0ZXN0L3VuaXQvY29tbW9uL2d1YXJkcy9hdXRoLmd1YXJkLnJlZ3Jlc3Npb24uc3BlYy50c1xuXG5pbXBvcnQgeyBFeGVjdXRpb25Db250ZXh0LCBVbmF1dGhvcml6ZWRFeGNlcHRpb24sIFNlcnZpY2VVbmF2YWlsYWJsZUV4Y2VwdGlvbiB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IENvbmZpZ1NlcnZpY2UgfSBmcm9tICdAbmVzdGpzL2NvbmZpZyc7XG5pbXBvcnQgeyBIdHRwU2VydmljZSB9IGZyb20gJ0BuZXN0anMvYXhpb3MnO1xuaW1wb3J0IHsgVGVzdCwgVGVzdGluZ01vZHVsZSB9IGZyb20gJ0BuZXN0anMvdGVzdGluZyc7XG5pbXBvcnQgeyBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQXhpb3NSZXNwb25zZSwgQXhpb3NFcnJvciB9IGZyb20gJ2F4aW9zJztcblxuaW1wb3J0IHsgQXV0aEd1YXJkIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbW1vbi9ndWFyZHMvYXV0aC5ndWFyZCc7XG5pbXBvcnQgeyBDYWNoZVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvY2FjaGUvY2FjaGUuc2VydmljZSc7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvbW1vbi9pbnRlcmZhY2VzL3VzZXIuaW50ZXJmYWNlJztcblxuZGVzY3JpYmUoJ0F1dGhHdWFyZCAtIFJlZ3Jlc3Npb24gVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBhdXRoR3VhcmQ6IEF1dGhHdWFyZDtcbiAgbGV0IGNvbmZpZ1NlcnZpY2U6IGplc3QuTW9ja2VkPENvbmZpZ1NlcnZpY2U+O1xuICBsZXQgY2FjaGVTZXJ2aWNlOiBqZXN0Lk1vY2tlZDxDYWNoZVNlcnZpY2U+O1xuICBsZXQgaHR0cFNlcnZpY2U6IGplc3QuTW9ja2VkPEh0dHBTZXJ2aWNlPjtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEhFTFBFUlMgREUgUsOJR1JFU1NJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGNvbnN0IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0ID0gKHJlcXVlc3Q6IGFueSk6IEV4ZWN1dGlvbkNvbnRleHQgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzd2l0Y2hUb0h0dHA6ICgpID0+ICh7XG4gICAgICAgIGdldFJlcXVlc3Q6ICgpID0+IHJlcXVlc3QsXG4gICAgICAgIGdldFJlc3BvbnNlOiBqZXN0LmZuKCksXG4gICAgICAgIGdldE5leHQ6IGplc3QuZm4oKSxcbiAgICAgIH0pLFxuICAgICAgc3dpdGNoVG9ScGM6IGplc3QuZm4oKSxcbiAgICAgIHN3aXRjaFRvV3M6IGplc3QuZm4oKSxcbiAgICAgIGdldFR5cGU6ICgpID0+ICdodHRwJyxcbiAgICAgIGdldENsYXNzOiBqZXN0LmZuKCksXG4gICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICBnZXRBcmdzOiBqZXN0LmZuKCksXG4gICAgICBnZXRBcmdCeUluZGV4OiBqZXN0LmZuKCksXG4gICAgfSBhcyBFeGVjdXRpb25Db250ZXh0O1xuICB9O1xuXG4gIGNvbnN0IGNyZWF0ZVZhbGlkVXNlciA9ICgpOiBVc2VyID0+ICh7XG4gICAgaWQ6ICdyZWdyZXNzaW9uLXVzZXItMTIzJyxcbiAgICBlbWFpbDogJ3JlZ3Jlc3Npb25AZXhhbXBsZS5jb20nLFxuICAgIHJvbGVzOiBbJ3VzZXInXSxcbiAgfSk7XG5cbiAgY29uc3QgY3JlYXRlVmFsaWRBdXRoUmVzcG9uc2UgPSAodXNlcjogVXNlciA9IGNyZWF0ZVZhbGlkVXNlcigpKTogQXhpb3NSZXNwb25zZSA9PiAoe1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgdXNlcjoge1xuICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgIHJvbGVzOiB1c2VyLnJvbGVzLFxuICAgICAgfSxcbiAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM2MDAwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgfSxcbiAgICBzdGF0dXM6IDIwMCxcbiAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIGNvbmZpZzoge30gYXMgYW55LFxuICB9KTtcblxuICBjb25zdCBjcmVhdGVSZWdyZXNzaW9uVG9rZW4gPSAoc2NlbmFyaW86IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIGBleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuJHtzY2VuYXJpb30tcmVncmVzc2lvbi10ZXN0LnNpZ25hdHVyZWA7XG4gIH07XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTRVRVUFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9kdWxlOiBUZXN0aW5nTW9kdWxlID0gYXdhaXQgVGVzdC5jcmVhdGVUZXN0aW5nTW9kdWxlKHtcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBBdXRoR3VhcmQsXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBDb25maWdTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiB7XG4gICAgICAgICAgICBnZXQ6IGplc3QuZm4oKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogQ2FjaGVTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiB7XG4gICAgICAgICAgICBnZXQ6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNldDogamVzdC5mbigpLFxuICAgICAgICAgICAgZGVsOiBqZXN0LmZuKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IEh0dHBTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiB7XG4gICAgICAgICAgICBwb3N0OiBqZXN0LmZuKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSkuY29tcGlsZSgpO1xuXG4gICAgYXV0aEd1YXJkID0gbW9kdWxlLmdldDxBdXRoR3VhcmQ+KEF1dGhHdWFyZCk7XG4gICAgY29uZmlnU2VydmljZSA9IG1vZHVsZS5nZXQoQ29uZmlnU2VydmljZSk7XG4gICAgY2FjaGVTZXJ2aWNlID0gbW9kdWxlLmdldChDYWNoZVNlcnZpY2UpO1xuICAgIGh0dHBTZXJ2aWNlID0gbW9kdWxlLmdldChIdHRwU2VydmljZSk7XG5cbiAgICBjb25maWdTZXJ2aWNlLmdldC5tb2NrSW1wbGVtZW50YXRpb24oKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICdBVVRIX1NFUlZJQ0VfVVJMJzpcbiAgICAgICAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG4gICAgICAgIGNhc2UgJ0FVVEhfU0VSVklDRV9USU1FT1VUJzpcbiAgICAgICAgICByZXR1cm4gJzUwMDAnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwcm9jZXNzLmVudi5BVVRIX1NFUlZJQ0VfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG4gICAgcHJvY2Vzcy5lbnYuQVVUSF9TRVJWSUNFX1RJTUVPVVQgPSAnNTAwMCc7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBURVNUUyBERSBSw4lHUkVTU0lPTiAtIEJVR1MgSElTVE9SSVFVRVMgRklYRVNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGRlc2NyaWJlKCdIaXN0b3JpY2FsIEJ1ZyBGaXhlcycsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBCdWcgRml4ICMwMDE6IE1lbW9yeSBsZWFrIHdoZW4gY2FjaGUgb3BlcmF0aW9ucyBmYWlsXG4gICAgICogRGF0ZTogMjAyNC0wMS0xNVxuICAgICAqIElzc3VlOiBGYWlsZWQgY2FjaGUgb3BlcmF0aW9ucyB3ZXJlIG5vdCBwcm9wZXJseSBjbGVhbmVkIHVwXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBub3QgbGVhayBtZW1vcnkgd2hlbiBjYWNoZSBvcGVyYXRpb25zIGZhaWwgcmVwZWF0ZWRseSAtIEJ1ZyAjMDAxJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVSZWdyZXNzaW9uVG9rZW4oJ21lbW9yeS1sZWFrLWZpeCcpO1xuICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZVZhbGlkVXNlcigpO1xuXG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ2FjaGUgY29ubmVjdGlvbiBmYWlsZWQnKSk7XG4gICAgICBjYWNoZVNlcnZpY2Uuc2V0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ2FjaGUgd3JpdGUgZmFpbGVkJykpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2YoY3JlYXRlVmFsaWRBdXRoUmVzcG9uc2UodXNlcikpKTtcblxuICAgICAgLy8gQWN0IC0gRXjDqWN1dGVyIHBsdXNpZXVycyBmb2lzIHBvdXIgdsOpcmlmaWVyIGxlcyBmdWl0ZXNcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3QgcmVmZXJlbmNlIHRvIGVuYWJsZSBHQ1xuICAgICAgICBkZWxldGUgKHJlcXVlc3QgYXMgYW55KS51c2VyO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3JjZSBHQyBpZiBhdmFpbGFibGVcbiAgICAgIGlmIChnbG9iYWwuZ2MpIGdsb2JhbC5nYygpO1xuICAgICAgXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IG1lbW9yeUdyb3d0aCA9IGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeTtcblxuICAgICAgLy8gQXNzZXJ0IC0gTWVtb3J5IGdyb3d0aCBzaG91bGQgYmUgbWluaW1hbFxuICAgICAgZXhwZWN0KG1lbW9yeUdyb3d0aCkudG9CZUxlc3NUaGFuKDUgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiA1TUJcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJ1ZyBGaXggIzAwMjogUmFjZSBjb25kaXRpb24gaW4gY29uY3VycmVudCB0b2tlbiB2YWxpZGF0aW9uXG4gICAgICogRGF0ZTogMjAyNC0wMS0yMFxuICAgICAqIElzc3VlOiBNdWx0aXBsZSBjb25jdXJyZW50IHJlcXVlc3RzIHdpdGggc2FtZSB0b2tlbiBjYXVzZWQgYXV0aCBzZXJ2aWNlIHNwYW1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IHJlcXVlc3RzIHdpdGggc2FtZSB0b2tlbiB3aXRob3V0IHJhY2UgY29uZGl0aW9ucyAtIEJ1ZyAjMDAyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVSZWdyZXNzaW9uVG9rZW4oJ3JhY2UtY29uZGl0aW9uLWZpeCcpO1xuICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZVZhbGlkVXNlcigpO1xuICAgICAgXG4gICAgICBsZXQgYXV0aFNlcnZpY2VDYWxsQ291bnQgPSAwO1xuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTsgLy8gQWx3YXlzIGNhY2hlIG1pc3MgZm9yIHRoaXMgdGVzdFxuICAgICAgXG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGF1dGhTZXJ2aWNlQ2FsbENvdW50Kys7XG4gICAgICAgIC8vIFNpbXVsYXRlIHNvbWUgcHJvY2Vzc2luZyB0aW1lIHdpdGggT2JzZXJ2YWJsZVxuICAgICAgICByZXR1cm4gb2Yoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM2MDAwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgIGNvbmZpZzoge30gYXMgYW55LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3QgLSA1MCBjb25jdXJyZW50IHJlcXVlc3RzIHdpdGggc2FtZSB0b2tlblxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA1MCB9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gcmVzdWx0ID09PSB0cnVlKSkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gTm90ZTogV2l0aG91dCBwcm9wZXIgZGVkdXBsaWNhdGlvbiwgdGhpcyB3aWxsIHN0aWxsIGNhbGwgdGhlIHNlcnZpY2UgNTAgdGltZXNcbiAgICAgIC8vIFRoaXMgdGVzdCBkb2N1bWVudHMgdGhlIGN1cnJlbnQgYmVoYXZpb3IgYW5kIHdpbGwgY2F0Y2ggY2hhbmdlc1xuICAgICAgZXhwZWN0KGF1dGhTZXJ2aWNlQ2FsbENvdW50KS50b0JlKDUwKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJ1ZyBGaXggIzAwMzogSW1wcm9wZXIgZXJyb3IgaGFuZGxpbmcgZm9yIG1hbGZvcm1lZCBKV1QgdG9rZW5zXG4gICAgICogRGF0ZTogMjAyNC0wMS0yNVxuICAgICAqIElzc3VlOiBNYWxmb3JtZWQgSldUIHRva2VucyBjYXVzZWQgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uc1xuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcHJvcGVybHkgaGFuZGxlIG1hbGZvcm1lZCBKV1QgdG9rZW5zIHdpdGhvdXQgdW5oYW5kbGVkIHJlamVjdGlvbnMgLSBCdWcgIzAwMycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1hbGZvcm1lZFRva2VucyA9IFtcbiAgICAgICAgJ25vdC5hLmp3dCcsIC8vIEludmFsaWQgZm9ybWF0XG4gICAgICAgICdleUpoYkdjaU9pSklVekkxTmlKOS5pbnZhbGlkLWJhc2U2NC0kJV4mLnNpZ25hdHVyZScsIC8vIEludmFsaWQgYmFzZTY0XG4gICAgICAgICdleUpoYkdjaU9pSklVekkxTmlKOS4uc2lnbmF0dXJlJywgLy8gRW1wdHkgcGF5bG9hZFxuICAgICAgICAnLmV5SjBaWE4wSWpvaWRHVnpkQ0o5LnNpZ25hdHVyZScsIC8vIEVtcHR5IGhlYWRlclxuICAgICAgXTtcblxuICAgICAgLy8gVHJhY2sgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICAgIGNvbnN0IHVuaGFuZGxlZFJlamVjdGlvbnM6IGFueVtdID0gW107XG4gICAgICBjb25zdCByZWplY3Rpb25IYW5kbGVyID0gKHJlYXNvbjogYW55KSA9PiB7XG4gICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChyZWFzb24pO1xuICAgICAgfTtcblxuICAgICAgcHJvY2Vzcy5vbigndW5oYW5kbGVkUmVqZWN0aW9uJywgcmVqZWN0aW9uSGFuZGxlcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEFjdFxuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1hbGZvcm1lZFRva2Vucykge1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBuZXcgQXhpb3NFcnJvcignTWFsZm9ybWVkIHRva2VuJywgJzQwMCcpKSk7XG5cbiAgICAgICAgICBhd2FpdCBleHBlY3QoYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS5yZWplY3RzLnRvVGhyb3coVW5hdXRob3JpemVkRXhjZXB0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgYSBiaXQgZm9yIGFueSBwb3RlbnRpYWwgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuXG4gICAgICAgIC8vIEFzc2VydFxuICAgICAgICBleHBlY3QodW5oYW5kbGVkUmVqZWN0aW9ucykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcHJvY2Vzcy5vZmYoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnVnIEZpeCAjMDA0OiBDYWNoZSBwb2lzb25pbmcgdnVsbmVyYWJpbGl0eVxuICAgICAqIERhdGU6IDIwMjQtMDItMDFcbiAgICAgKiBJc3N1ZTogQ2FjaGUga2V5cyB3ZXJlIG5vdCBwcm9wZXJseSBzYW5pdGl6ZWQgYWxsb3dpbmcgY2FjaGUgcG9pc29uaW5nXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBwcmV2ZW50IGNhY2hlIHBvaXNvbmluZyB0aHJvdWdoIG1hbGljaW91cyB0b2tlbnMgLSBCdWcgIzAwNCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1hbGljaW91c1Rva2VucyA9IFtcbiAgICAgICAgJ2FkbWluLW92ZXJyaWRlJyxcbiAgICAgICAgJy4uLy4uLy4uL2NhY2hlL2FkbWluJyxcbiAgICAgICAgJ2F1dGg6dG9rZW46YWRtaW4tdXNlcicsXG4gICAgICAgICd1c2VyXFx4MDBhZG1pbicsXG4gICAgICBdO1xuXG4gICAgICBjb25zdCB1c2VyID0gY3JlYXRlVmFsaWRVc2VyKCk7XG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2YoY3JlYXRlVmFsaWRBdXRoUmVzcG9uc2UodXNlcikpKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1hbGljaW91c1Rva2Vucykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICAgIGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcblxuICAgICAgICAvLyBWZXJpZnkgY2FjaGUga2V5IGlzIHByb3Blcmx5IGhhc2hlZCBhbmQgY2Fubm90IGJlIG1hbmlwdWxhdGVkXG4gICAgICAgIGV4cGVjdChjYWNoZVNlcnZpY2Uuc2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL15hdXRoOnRva2VuOlthLWYwLTldezY0fSQvKSxcbiAgICAgICAgICB1c2VyLFxuICAgICAgICAgIGV4cGVjdC5hbnkoTnVtYmVyKVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY2FjaGVTZXJ2aWNlLnNldC5tb2NrLmNhbGxzW2NhY2hlU2VydmljZS5zZXQubW9jay5jYWxscy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgZXhwZWN0KGNhY2hlS2V5KS5ub3QudG9Db250YWluKCdhZG1pbicpO1xuICAgICAgICBleHBlY3QoY2FjaGVLZXkpLm5vdC50b0NvbnRhaW4oJ292ZXJyaWRlJyk7XG4gICAgICAgIGV4cGVjdChjYWNoZUtleSkubm90LnRvQ29udGFpbignLi4vJyk7XG4gICAgICAgIGV4cGVjdChjYWNoZUtleSkubm90LnRvQ29udGFpbignXFx4MDAnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJ1ZyBGaXggIzAwNTogVGltZW91dCBoYW5kbGluZyBub3Qgd29ya2luZyBwcm9wZXJseVxuICAgICAqIERhdGU6IDIwMjQtMDItMTBcbiAgICAgKiBJc3N1ZTogSFRUUCB0aW1lb3V0cyB3ZXJlIG5vdCBwcm9wZXJseSBjYXVnaHQgYW5kIGNvbnZlcnRlZCB0byBhcHByb3ByaWF0ZSBleGNlcHRpb25zXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBwcm9wZXJseSBoYW5kbGUgYW5kIGNvbnZlcnQgdGltZW91dCBlcnJvcnMgLSBCdWcgIzAwNScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gY3JlYXRlUmVncmVzc2lvblRva2VuKCd0aW1lb3V0LWZpeCcpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHRpbWVvdXRFcnJvcnMgPSBbXG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCd0aW1lb3V0IG9mIDUwMDBtcyBleGNlZWRlZCcpLCB7IGNvZGU6ICdFVElNRURPVVQnIH0pLFxuICAgICAgICBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignc29ja2V0IGhhbmcgdXAnKSwgeyBjb2RlOiAnRUNPTk5SRVNFVCcgfSksXG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdyZXF1ZXN0IHRpbWVvdXQnKSwgeyBjb2RlOiAnRUNPTk5BQk9SVEVEJyB9KSxcbiAgICAgICAgbmV3IEF4aW9zRXJyb3IoJ3RpbWVvdXQnLCAnRUNPTk5BQk9SVEVEJyksXG4gICAgICBdO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgdGltZW91dEVycm9ycykge1xuICAgICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IGVycm9yKSk7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KSkucmVqZWN0cy50b1Rocm93KFNlcnZpY2VVbmF2YWlsYWJsZUV4Y2VwdGlvbik7XG4gICAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdygnQXV0aGVudGljYXRpb24gc2VydmljZSB1bmF2YWlsYWJsZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnVnIEZpeCAjMDA2OiBVc2VyIG9iamVjdCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgICogRGF0ZTogMjAyNC0wMi0xNVxuICAgICAqIElzc3VlOiBVc2VyIG9iamVjdHMgZnJvbSBjYWNoZSBjb3VsZCBwb2xsdXRlIHByb3RvdHlwZXNcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvbiBmcm9tIGNhY2hlZCB1c2VyIG9iamVjdHMgLSBCdWcgIzAwNicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gY3JlYXRlUmVncmVzc2lvblRva2VuKCdwcm90b3R5cGUtcG9sbHV0aW9uLWZpeCcpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgIC8vIE1hbGljaW91cyB1c2VyIG9iamVjdCB3aXRoIHByb3RvdHlwZSBwb2xsdXRpb24gYXR0ZW1wdFxuICAgICAgY29uc3QgbWFsaWNpb3VzVXNlciA9IHtcbiAgICAgICAgaWQ6ICd1c2VyLTEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVzOiBbJ3VzZXInXSxcbiAgICAgICAgX19wcm90b19fOiB7IGlzQWRtaW46IHRydWUgfSxcbiAgICAgICAgY29uc3RydWN0b3I6IHsgcHJvdG90eXBlOiB7IHBvbGx1dGVkOiB0cnVlIH0gfSxcbiAgICAgIH07XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobWFsaWNpb3VzVXNlcik7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBubyBwcm90b3R5cGUgcG9sbHV0aW9uIG9jY3VycmVkXG4gICAgICBleHBlY3QoKE9iamVjdC5wcm90b3R5cGUgYXMgYW55KS5pc0FkbWluKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QoKE9iamVjdC5wcm90b3R5cGUgYXMgYW55KS5wb2xsdXRlZCkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgXG4gICAgICAvLyBVc2VyIHNob3VsZCBiZSBjbGVhbmVkL3ZhbGlkYXRlZFxuICAgICAgY29uc3QgaW5qZWN0ZWRVc2VyID0gKHJlcXVlc3QgYXMgYW55KS51c2VyO1xuICAgICAgZXhwZWN0KGluamVjdGVkVXNlci5pZCkudG9CZSgndXNlci0xMjMnKTtcbiAgICAgIGV4cGVjdChpbmplY3RlZFVzZXIuZW1haWwpLnRvQmUoJ3Rlc3RAZXhhbXBsZS5jb20nKTtcbiAgICAgIGV4cGVjdChpbmplY3RlZFVzZXIucm9sZXMpLnRvRXF1YWwoWyd1c2VyJ10pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQnVnIEZpeCAjMDA3OiBJbmNvbnNpc3RlbnQgZXJyb3IgbWVzc2FnZXNcbiAgICAgKiBEYXRlOiAyMDI0LTAyLTIwXG4gICAgICogSXNzdWU6IERpZmZlcmVudCBlcnJvciBzY2VuYXJpb3MgcmV0dXJuZWQgaW5jb25zaXN0ZW50IGVycm9yIG1lc3NhZ2VzXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gY29uc2lzdGVudCBlcnJvciBtZXNzYWdlcyBmb3IgYXV0aGVudGljYXRpb24gZmFpbHVyZXMgLSBCdWcgIzAwNycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHNjZW5hcmlvcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdpbnZhbGlkLXRva2VuJyxcbiAgICAgICAgICBzZXR1cDogKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgICAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKHRocm93RXJyb3IoKCkgPT4gbmV3IEF4aW9zRXJyb3IoJ0ludmFsaWQgdG9rZW4nLCAnNDAxJykpKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2V4cGlyZWQtdG9rZW4nLFxuICAgICAgICAgIHNldHVwOiAoKSA9PiB7XG4gICAgICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBuZXcgQXhpb3NFcnJvcignVG9rZW4gZXhwaXJlZCcsICc0MDEnKSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnbWFsZm9ybWVkLXJlc3BvbnNlJyxcbiAgICAgICAgICBzZXR1cDogKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgICAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKHtcbiAgICAgICAgICAgICAgZGF0YTogeyB2YWxpZDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICBjb25maWc6IHt9IGFzIGFueSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBmb3IgKGNvbnN0IHNjZW5hcmlvIG9mIHNjZW5hcmlvcykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGNyZWF0ZVJlZ3Jlc3Npb25Ub2tlbihzY2VuYXJpby5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBzY2VuYXJpby5zZXR1cCgpO1xuXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpLmNhdGNoKGUgPT4gZSk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmVJbnN0YW5jZU9mKFVuYXV0aG9yaXplZEV4Y2VwdGlvbik7XG4gICAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS50b0JlKCdBdXRoZW50aWNhdGlvbiBmYWlsZWQnKTsgLy8gQ29uc2lzdGVudCBtZXNzYWdlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCdWcgRml4ICMwMDg6IENhY2hlIFRUTCBub3QgYmVpbmcgcmVzcGVjdGVkXG4gICAgICogRGF0ZTogMjAyNC0wMy0wMVxuICAgICAqIElzc3VlOiBDYWNoZSBUVEwgd2FzIGhhcmRjb2RlZCBhbmQgbm90IGNvbmZpZ3VyYWJsZVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgdXNlIGNvbmZpZ3VyYWJsZSBjYWNoZSBUVEwgLSBCdWcgIzAwOCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGN1c3RvbVRUTCA9IDYwMDsgLy8gMTAgbWludXRlc1xuICAgICAgY29uZmlnU2VydmljZS5nZXQubW9ja0ltcGxlbWVudGF0aW9uKChrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ0FVVEhfU0VSVklDRV9VUkwnOlxuICAgICAgICAgICAgcmV0dXJuICdodHRwOi8vbG9jYWxob3N0OjMwMDEnO1xuICAgICAgICAgIGNhc2UgJ0FVVEhfU0VSVklDRV9USU1FT1VUJzpcbiAgICAgICAgICAgIHJldHVybiAnNTAwMCc7XG4gICAgICAgICAgY2FzZSAnQVVUSF9DQUNIRV9UVEwnOlxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbVRUTC50b1N0cmluZygpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVSZWdyZXNzaW9uVG9rZW4oJ2NhY2hlLXR0bC1maXgnKTtcbiAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVWYWxpZFVzZXIoKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHJlcXVlc3QpO1xuXG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2YoY3JlYXRlVmFsaWRBdXRoUmVzcG9uc2UodXNlcikpKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGNhY2hlU2VydmljZS5zZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL15hdXRoOnRva2VuOlthLWYwLTldezY0fSQvKSxcbiAgICAgICAgdXNlcixcbiAgICAgICAgY3VzdG9tVFRMXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRFU1RTIERFIFLDiUdSRVNTSU9OIC0gQ09NUEFUSUJJTElUw4kgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBkZXNjcmliZSgnQVBJIENvbXBhdGliaWxpdHkgUmVncmVzc2lvbicsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBDb21wYXRpYmlsaXR5IFRlc3Q6IEV4ZWN1dGlvbkNvbnRleHQgaW50ZXJmYWNlXG4gICAgICogRW5zdXJlcyB0aGUgZ3VhcmQgc3RpbGwgd29ya3Mgd2l0aCBkaWZmZXJlbnQgRXhlY3V0aW9uQ29udGV4dCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBkaWZmZXJlbnQgRXhlY3V0aW9uQ29udGV4dCBpbXBsZW1lbnRhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9IGNyZWF0ZVJlZ3Jlc3Npb25Ub2tlbignY29udGV4dC1jb21wYXRpYmlsaXR5Jyk7XG4gICAgICBjb25zdCB1c2VyID0gY3JlYXRlVmFsaWRVc2VyKCk7XG5cbiAgICAgIC8vIERpZmZlcmVudCBFeGVjdXRpb25Db250ZXh0IGltcGxlbWVudGF0aW9uc1xuICAgICAgY29uc3QgY29udGV4dHMgPSBbXG4gICAgICAgIC8vIFN0YW5kYXJkIEhUVFAgY29udGV4dFxuICAgICAgICB7XG4gICAgICAgICAgc3dpdGNoVG9IdHRwOiAoKSA9PiAoe1xuICAgICAgICAgICAgZ2V0UmVxdWVzdDogKCkgPT4gKHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH0pLFxuICAgICAgICAgICAgZ2V0UmVzcG9uc2U6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGdldE5leHQ6IGplc3QuZm4oKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzd2l0Y2hUb1JwYzogamVzdC5mbigpLFxuICAgICAgICAgIHN3aXRjaFRvV3M6IGplc3QuZm4oKSxcbiAgICAgICAgICBnZXRUeXBlOiAoKSA9PiAnaHR0cCcgYXMgY29uc3QsXG4gICAgICAgICAgZ2V0Q2xhc3M6IGplc3QuZm4oKSxcbiAgICAgICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICAgICAgZ2V0QXJnczogamVzdC5mbigpLFxuICAgICAgICAgIGdldEFyZ0J5SW5kZXg6IGplc3QuZm4oKSxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ29udGV4dCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICAgICAgICB7XG4gICAgICAgICAgc3dpdGNoVG9IdHRwOiAoKSA9PiAoe1xuICAgICAgICAgICAgZ2V0UmVxdWVzdDogKCkgPT4gKHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH0pLFxuICAgICAgICAgICAgZ2V0UmVzcG9uc2U6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIGdldE5leHQ6IGplc3QuZm4oKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzd2l0Y2hUb1JwYzogamVzdC5mbigpLFxuICAgICAgICAgIHN3aXRjaFRvV3M6IGplc3QuZm4oKSxcbiAgICAgICAgICBnZXRUeXBlOiAoKSA9PiAnaHR0cCcgYXMgY29uc3QsXG4gICAgICAgICAgZ2V0Q2xhc3M6IGplc3QuZm4oKSxcbiAgICAgICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICAgICAgZ2V0QXJnczogamVzdC5mbigpLFxuICAgICAgICAgIGdldEFyZ0J5SW5kZXg6IGplc3QuZm4oKSxcbiAgICAgICAgICAvLyBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgICAgICBjdXN0b21Qcm9wZXJ0eTogJ3Rlc3QnLFxuICAgICAgICAgIGdldEN1c3RvbURhdGE6IGplc3QuZm4oKSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUodXNlcik7XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgZm9yIChjb25zdCBjb250ZXh0IG9mIGNvbnRleHRzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0IGFzIEV4ZWN1dGlvbkNvbnRleHQpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29tcGF0aWJpbGl0eSBUZXN0OiBEaWZmZXJlbnQgVXNlciBpbnRlcmZhY2UgdmVyc2lvbnNcbiAgICAgKiBFbnN1cmVzIHRoZSBndWFyZCBoYW5kbGVzIGV2b2x1dGlvbiBvZiB0aGUgVXNlciBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkaWZmZXJlbnQgVXNlciBpbnRlcmZhY2UgdmVyc2lvbnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHRva2VuID0gY3JlYXRlUmVncmVzc2lvblRva2VuKCd1c2VyLWludGVyZmFjZS1jb21wYXRpYmlsaXR5Jyk7XG5cbiAgICAgIGNvbnN0IHVzZXJWZXJzaW9ucyA9IFtcbiAgICAgICAgLy8gTWluaW1hbCB1c2VyIChvcmlnaW5hbCB2ZXJzaW9uKVxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd1c2VyLTEyMycsXG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICByb2xlczogWyd1c2VyJ10sXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEV4dGVuZGVkIHVzZXIgKHdpdGggYWRkaXRpb25hbCBmaWVsZHMpXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3VzZXItNDU2JyxcbiAgICAgICAgICBlbWFpbDogJ2V4dGVuZGVkQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICByb2xlczogWyd1c2VyJywgJ2FkbWluJ10sXG4gICAgICAgICAgcHJvZmlsZTogeyBuYW1lOiAnVGVzdCBVc2VyJyB9LFxuICAgICAgICAgIG1ldGFkYXRhOiB7IGxhc3RMb2dpbjogJzIwMjQtMDEtMDEnIH0sXG4gICAgICAgICAgcGVybWlzc2lvbnM6IFsncmVhZCcsICd3cml0ZSddLFxuICAgICAgICB9LFxuICAgICAgICAvLyBVc2VyIHdpdGggbWluaW1hbCByb2xlc1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd1c2VyLTc4OScsXG4gICAgICAgICAgZW1haWw6ICdtaW5pbWFsQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICByb2xlczogW10sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGZvciAoY29uc3QgdXNlciBvZiB1c2VyVmVyc2lvbnMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHVzZXIpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhHdWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KChyZXF1ZXN0IGFzIGFueSkudXNlcikudG9FcXVhbCh1c2VyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbXBhdGliaWxpdHkgVGVzdDogQ29uZmlnU2VydmljZSBjaGFuZ2VzXG4gICAgICogRW5zdXJlcyB0aGUgZ3VhcmQgYWRhcHRzIHRvIENvbmZpZ1NlcnZpY2UgaW50ZXJmYWNlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBDb25maWdTZXJ2aWNlIGludGVyZmFjZSBjaGFuZ2VzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b2tlbiA9IGNyZWF0ZVJlZ3Jlc3Npb25Ub2tlbignY29uZmlnLWNvbXBhdGliaWxpdHknKTtcbiAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVWYWxpZFVzZXIoKTtcblxuICAgICAgLy8gVGVzdCB3aXRoIENvbmZpZ1NlcnZpY2UgdGhhdCB0aHJvd3MgZm9yIHVua25vd24ga2V5c1xuICAgICAgY29uc3Qgc3RyaWN0Q29uZmlnU2VydmljZSA9IHtcbiAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbmZpZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgICAgICdBVVRIX1NFUlZJQ0VfVVJMJzogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMScsXG4gICAgICAgICAgICAnQVVUSF9TRVJWSUNFX1RJTUVPVVQnOiAnNTAwMCcsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gY29uZmlnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbmZpZ3VyYXRpb24ga2V5OiAke2tleX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZ1trZXldO1xuICAgICAgICB9KSxcbiAgICAgIH07XG5cbiAgICAgIC8vIENyZWF0ZSBuZXcgZ3VhcmQgaW5zdGFuY2Ugd2l0aCBzdHJpY3QgY29uZmlnXG4gICAgICBjb25zdCBzdHJpY3RHdWFyZCA9IG5ldyBBdXRoR3VhcmQoXG4gICAgICAgIHN0cmljdENvbmZpZ1NlcnZpY2UgYXMgYW55LFxuICAgICAgICBjYWNoZVNlcnZpY2UsXG4gICAgICAgIGh0dHBTZXJ2aWNlXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gfTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKGNyZWF0ZVZhbGlkQXV0aFJlc3BvbnNlKHVzZXIpKSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RyaWN0R3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCgocmVxdWVzdCBhcyBhbnkpLnVzZXIpLnRvRXF1YWwodXNlcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gVEVTVFMgREUgUsOJR1JFU1NJT04gLSBQRVJGT1JNQU5DRVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFJlZ3Jlc3Npb24nLCAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybWFuY2UgUmVncmVzc2lvbjogQXV0aGVudGljYXRpb24gc3BlZWQgYmFzZWxpbmVcbiAgICAgKiBFbnN1cmVzIHBlcmZvcm1hbmNlIGRvZXNuJ3QgZGVncmFkZSBvdmVyIHRpbWVcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIG1haW50YWluIGF1dGhlbnRpY2F0aW9uIHBlcmZvcm1hbmNlIGJhc2VsaW5lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVSZWdyZXNzaW9uVG9rZW4oJ3BlcmZvcm1hbmNlLWJhc2VsaW5lJyk7XG4gICAgICBjb25zdCB1c2VyID0gY3JlYXRlVmFsaWRVc2VyKCk7XG5cbiAgICAgIC8vIFRlc3QgY2FjaGUgaGl0IHBlcmZvcm1hbmNlXG4gICAgICBjb25zdCBjYWNoZUhpdFRpbWVzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZSh1c2VyKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcbiAgICAgICAgYXdhaXQgYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xuICAgICAgICBjb25zdCBlbmQgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcbiAgICAgICAgXG4gICAgICAgIGNhY2hlSGl0VGltZXMucHVzaChOdW1iZXIoZW5kIC0gc3RhcnQpIC8gMTAwMDAwMCk7IC8vIENvbnZlcnQgdG8gbXNcbiAgICAgIH1cblxuICAgICAgLy8gVGVzdCBjYWNoZSBtaXNzIHBlcmZvcm1hbmNlXG4gICAgICBjb25zdCBjYWNoZU1pc3NUaW1lczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGNhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBodHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZihjcmVhdGVWYWxpZEF1dGhSZXNwb25zZSh1c2VyKSkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBjb25zdCBzdGFydCA9IHByb2Nlc3MuaHJ0aW1lLmJpZ2ludCgpO1xuICAgICAgICBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHByb2Nlc3MuaHJ0aW1lLmJpZ2ludCgpO1xuICAgICAgICBcbiAgICAgICAgY2FjaGVNaXNzVGltZXMucHVzaChOdW1iZXIoZW5kIC0gc3RhcnQpIC8gMTAwMDAwMCk7IC8vIENvbnZlcnQgdG8gbXNcbiAgICAgIH1cblxuICAgICAgLy8gQXNzZXJ0IC0gUGVyZm9ybWFuY2UgYmFzZWxpbmVzIChhZGp1c3QgYmFzZWQgb24geW91ciByZXF1aXJlbWVudHMpXG4gICAgICBjb25zdCBhdmdDYWNoZUhpdFRpbWUgPSBjYWNoZUhpdFRpbWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gY2FjaGVIaXRUaW1lcy5sZW5ndGg7XG4gICAgICBjb25zdCBhdmdDYWNoZU1pc3NUaW1lID0gY2FjaGVNaXNzVGltZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBjYWNoZU1pc3NUaW1lcy5sZW5ndGg7XG5cbiAgICAgIGV4cGVjdChhdmdDYWNoZUhpdFRpbWUpLnRvQmVMZXNzVGhhbig1KTsgLy8gQ2FjaGUgaGl0cyBzaG91bGQgYmUgdW5kZXIgNW1zXG4gICAgICBleHBlY3QoYXZnQ2FjaGVNaXNzVGltZSkudG9CZUxlc3NUaGFuKDUwKTsgLy8gQ2FjaGUgbWlzc2VzIHNob3VsZCBiZSB1bmRlciA1MG1zXG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFBlcmZvcm1hbmNlIEJhc2VsaW5lIC0gQ2FjaGUgSGl0OiAke2F2Z0NhY2hlSGl0VGltZS50b0ZpeGVkKDIpfW1zLCBDYWNoZSBNaXNzOiAke2F2Z0NhY2hlTWlzc1RpbWUudG9GaXhlZCgyKX1tc2ApO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybWFuY2UgUmVncmVzc2lvbjogTWVtb3J5IHVzYWdlIGJhc2VsaW5lXG4gICAgICogRW5zdXJlcyBtZW1vcnkgdXNhZ2UgZG9lc24ndCBncm93IG92ZXIgdGltZVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gbWVtb3J5IHVzYWdlIGJhc2VsaW5lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZVZhbGlkVXNlcigpO1xuICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGh0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKGNyZWF0ZVZhbGlkQXV0aFJlc3BvbnNlKHVzZXIpKSk7XG5cbiAgICAgIC8vIE1lYXN1cmUgbWVtb3J5IGJlZm9yZSBvcGVyYXRpb25zXG4gICAgICBpZiAoZ2xvYmFsLmdjKSBnbG9iYWwuZ2MoKTtcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG5cbiAgICAgIC8vIEFjdCAtIFBlcmZvcm0gbWFueSBvcGVyYXRpb25zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGNyZWF0ZVJlZ3Jlc3Npb25Ub2tlbihgbWVtb3J5LWJhc2VsaW5lLSR7aX1gKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgaGVhZGVyczogeyBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dChyZXF1ZXN0KTtcblxuICAgICAgICBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhbiB1cCB0byBlbmFibGUgR0NcbiAgICAgICAgZGVsZXRlIChyZXF1ZXN0IGFzIGFueSkudXNlcjtcbiAgICAgIH1cblxuICAgICAgLy8gTWVhc3VyZSBtZW1vcnkgYWZ0ZXIgb3BlcmF0aW9uc1xuICAgICAgaWYgKGdsb2JhbC5nYykgZ2xvYmFsLmdjKCk7XG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IG1lbW9yeUdyb3d0aCA9IGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeTtcblxuICAgICAgLy8gQXNzZXJ0IC0gTWVtb3J5IGdyb3d0aCBzaG91bGQgYmUgbWluaW1hbFxuICAgICAgZXhwZWN0KG1lbW9yeUdyb3d0aCkudG9CZUxlc3NUaGFuKDUwICogMTAyNCAqIDEwMjQpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBNZW1vcnkgQmFzZWxpbmUgLSBHcm93dGg6ICR7KG1lbW9yeUdyb3d0aCAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfU1CYCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gVEVTVFMgREUgUsOJR1JFU1NJT04gLSBTw4lDVVJJVMOJXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBkZXNjcmliZSgnU2VjdXJpdHkgUmVncmVzc2lvbicsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBTZWN1cml0eSBSZWdyZXNzaW9uOiBUb2tlbiB2YWxpZGF0aW9uIGJ5cGFzcyBhdHRlbXB0c1xuICAgICAqIEVuc3VyZXMgc2VjdXJpdHkgZml4ZXMgYXJlIG5vdCByZWdyZXNzZWRcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgYWxsIGtub3duIHRva2VuIHZhbGlkYXRpb24gYnlwYXNzIGF0dGVtcHRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZSAtIEtub3duIGJ5cGFzcyBhdHRlbXB0cyBmcm9tIHNlY3VyaXR5IGF1ZGl0c1xuICAgICAgY29uc3QgYnlwYXNzQXR0ZW1wdHMgPSBbXG4gICAgICAgICdCZWFyZXIgbnVsbCcsXG4gICAgICAgICdCZWFyZXIgdW5kZWZpbmVkJyxcbiAgICAgICAgJ0JlYXJlciBmYWxzZScsXG4gICAgICAgICdCZWFyZXIgMCcsXG4gICAgICAgICdCZWFyZXIge30nLFxuICAgICAgICAnQmVhcmVyIFtdJyxcbiAgICAgICAgJ0JlYXJlciBcIlwiJyxcbiAgICAgICAgJ0JlYXJlciBhZG1pbicsXG4gICAgICAgICdCZWFyZXIgdHJ1ZScsXG4gICAgICAgICdCZWFyZXIgMScsXG4gICAgICAgICdCZWFyZXIgKicsXG4gICAgICAgICdCZWFyZXIgJScsXG4gICAgICAgICdCZWFyZXIgLycsXG4gICAgICAgICdCZWFyZXIgXFxcXCcsXG4gICAgICBdO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGZvciAoY29uc3QgYXV0aCBvZiBieXBhc3NBdHRlbXB0cykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGF1dGggfSB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBuZXcgQXhpb3NFcnJvcignSW52YWxpZCB0b2tlbicsICc0MDEnKSkpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkpLnJlamVjdHMudG9UaHJvdyhVbmF1dGhvcml6ZWRFeGNlcHRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU2VjdXJpdHkgUmVncmVzc2lvbjogQ2FjaGUga2V5IG1hbmlwdWxhdGlvbiBhdHRlbXB0c1xuICAgICAqIEVuc3VyZXMgY2FjaGUga2V5IHNlY3VyaXR5IGlzIG1haW50YWluZWRcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgY2FjaGUga2V5IG1hbmlwdWxhdGlvbiBhdHRlbXB0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1hbmlwdWxhdGlvbkF0dGVtcHRzID0gW1xuICAgICAgICAnYXV0aDp0b2tlbjphZG1pbicsXG4gICAgICAgICcuLi9jYWNoZS9hZG1pbicsXG4gICAgICAgICcuLi8uLi9zeXN0ZW0vcm9vdCcsXG4gICAgICAgICdjYWNoZVxceDAwYWRtaW4nLFxuICAgICAgICAndG9rZW5cXHJcXG5hZG1pbicsXG4gICAgICAgICd0b2tlblxcbmFkbWluXFxydXNlcicsXG4gICAgICBdO1xuXG4gICAgICBjb25zdCB1c2VyID0gY3JlYXRlVmFsaWRVc2VyKCk7XG4gICAgICBjYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2YoY3JlYXRlVmFsaWRBdXRoUmVzcG9uc2UodXNlcikpKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1hbmlwdWxhdGlvbkF0dGVtcHRzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgICAgYXdhaXQgYXV0aEd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xuXG4gICAgICAgIC8vIFZlcmlmeSBjYWNoZSBrZXkgaXMgcHJvcGVybHkgaGFzaGVkIGFuZCBzYW5pdGl6ZWRcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBjYWNoZVNlcnZpY2Uuc2V0Lm1vY2suY2FsbHNbY2FjaGVTZXJ2aWNlLnNldC5tb2NrLmNhbGxzLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICBleHBlY3QoY2FjaGVLZXkpLnRvTWF0Y2goL15hdXRoOnRva2VuOlthLWYwLTldezY0fSQvKTtcbiAgICAgICAgZXhwZWN0KGNhY2hlS2V5KS5ub3QudG9Db250YWluKCdhZG1pbicpO1xuICAgICAgICBleHBlY3QoY2FjaGVLZXkpLm5vdC50b0NvbnRhaW4oJy4uLycpO1xuICAgICAgICBleHBlY3QoY2FjaGVLZXkpLm5vdC50b0NvbnRhaW4oJ1xceDAwJyk7XG4gICAgICAgIGV4cGVjdChjYWNoZUtleSkubm90LnRvQ29udGFpbignXFxyJyk7XG4gICAgICAgIGV4cGVjdChjYWNoZUtleSkubm90LnRvQ29udGFpbignXFxuJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTZWN1cml0eSBSZWdyZXNzaW9uOiBJbmZvcm1hdGlvbiBkaXNjbG9zdXJlIHByZXZlbnRpb25cbiAgICAgKiBFbnN1cmVzIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiBpcyBub3QgbGVha2VkIGluIGVycm9yc1xuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcHJldmVudCBpbmZvcm1hdGlvbiBkaXNjbG9zdXJlIGluIGVycm9yIG1lc3NhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3Qgc2Vuc2l0aXZlVG9rZW5zID0gW1xuICAgICAgICAnZXlKaGJHY2lPaUpJVXpJMU5pSjkuZXlKelpXTnlaWFFpT2lKemRYQmxjaTF6WldOeVpYUXRhVzVtYjNKdFlYUnBiMjRpZlEuc2lnbmF0dXJlJyxcbiAgICAgICAgJ3Byb2R1Y3Rpb24tYWRtaW4tdG9rZW4td2l0aC1zZWNyZXRzJyxcbiAgICAgICAgJ0JlYXJlciBpbnRlcm5hbC1zZXJ2aWNlLWtleS0xMjM0NScsXG4gICAgICBdO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2Ygc2Vuc2l0aXZlVG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfSB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQocmVxdWVzdCk7XG5cbiAgICAgICAgY2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgICAgaHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBuZXcgQXhpb3NFcnJvcignSW50ZXJuYWwgc2VydmVyIGVycm9yJywgJzUwMCcpKSk7XG5cbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCBhdXRoR3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCkuY2F0Y2goZSA9PiBlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSBubyBzZW5zaXRpdmUgaW5mb3JtYXRpb24gaXMgbGVha2VkXG4gICAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS5ub3QudG9Db250YWluKHRva2VuKTtcbiAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLm5vdC50b0NvbnRhaW4oJ3NlY3JldCcpO1xuICAgICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkubm90LnRvQ29udGFpbignYWRtaW4tdG9rZW4nKTtcbiAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLm5vdC50b0NvbnRhaW4oJ3NlcnZpY2Uta2V5Jyk7XG4gICAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS5ub3QudG9Db250YWluKCdwcm9kdWN0aW9uJyk7XG4gICAgICAgIGV4cGVjdChlcnJvci5zdGFjayB8fCAnJykubm90LnRvQ29udGFpbih0b2tlbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9